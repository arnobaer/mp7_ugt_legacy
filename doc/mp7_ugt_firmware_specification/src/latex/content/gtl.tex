\section{Global Trigger Logic}
\label{sec:gtl:global_trigger_logic}
\textbf{Remark:}\\
This description is for version 1.11.0 of Global Trigger Logic.\\

The Global Trigger Logic (\ugtl) firmware contains conditions and Algorithms for trigger decision.

\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{figures/mGTL_firmware}
\caption{\ugtl firmware} 
\label{fig:gtl:mGTL_firmware}
\end{figure}

\subsection{\ugtl Interface}
\label{sec:gtl:ugtl_interface}

\textbf{Inputs:}
\begin{itemize}
\item Calo-Layer2 data
\begin{itemize}
\item Electron/$\gamma$ objects
\item Jet objects
\item Tau objects
\item Energy summary information: Total Et (\ett), total Et from ECAL only (ETTEM), total calibrated Et in jets (\htt), missing Et (\etm), missing Et including HF (ET$_{miss}^{HF}$), missing Ht objects (\htm),
missing Ht including HF (HT$_{miss}^{HF}$) and "Asymmetry" information (ASYMET, ASYMHT, ASYMETHF, ASYMHTHF) 
\item Minimum bias HF bits (included in energy summary information data structure)
\item Towercount bits (number of firing HCAL towers, included in energy summary information data structure)
\item "Centrality" bits
\end{itemize}
\item \gmt data
\item External conditions
\item LHC-clock 
\end{itemize}
\textbf{Outputs:}
\begin{itemize}
\item Algorithms
\end{itemize}

\subsection{Definition of optical interfaces}
\label{sec:gtl:optical_interfaces}

Remark: all definitions for scales in the following chapters are from a CMS Detector Note: "Scales for inputs to $\mu$GT" (see actual version in \url{https://raw.githubusercontent.com/cms-l1-globaltrigger/mp7_ugt_legacy/master/doc/scales_inputs_2_ugt/pdf/scales_inputs_2_ugt.pdf}).

\subsubsection{Calo-Layer2 optical interfaces}
\label{sec:gtl:gct_optical_interfaces}

The configuration of optical connections from Calo-Layer2 to \ugt is shown in Table~\ref{tab:framework:tab_configuration_optical_conn}.\\
% \textit{The location of the GTH channels for the connections is very preliminary, must be checked with connections on Calo-Layer2.}\\

The data structure of an \egamma object (bits 27..31 are not defined yet, reserved for quality, ...):
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,8,9,16,17,24,25,26,27,31} \\
        \bitbox {5}     {\texttt{qual/spare}} &
        \bitbox {2}     {\texttt{iso}} &
        \bitbox {8}     {\texttt{$\varphi$}}  &
        \bitbox {8}     {\texttt{$\eta$}}  &
        \bitbox {9}     {\texttt{\et}} \\
\end{bytefield}
\end{center}

The data structure of a jet object (bits 27..31 are not defined yet, reserved for quality, ...):
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,10,11,18,19,26,27,31} \\
        \bitbox {5}     {\texttt{iso/qu/sp}} &
        \bitbox {8}     {\texttt{$\varphi$}}  &
        \bitbox {8}     {\texttt{$\eta$}}  &
        \bitbox {11}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

The data structure of a tau object (bits 27..31 are not defined yet, reserved for quality, ...):
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,8,9,16,17,24,25,26,27,31} \\
        \bitbox {5}     {\texttt{qual/spare}} &
        \bitbox {2}     {\texttt{iso}} &
        \bitbox {8}     {\texttt{$\varphi$}}  &
        \bitbox {8}     {\texttt{$\eta$}}  &
        \bitbox {9}     {\texttt{\et}} \\
\end{bytefield}
\end{center}

The data structure of "total Et" (\ett) quantity [including "total Et from ECAL only" (ETTEM) and "minimum bias HF+ threshold 0" bits]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,23,24,27,28,31} \\
        \bitbox {4}    {\texttt{MBT0HFP}} &
        \bitbox {4}    {\texttt{spare}} &
        \bitbox {12}    {\texttt{\et [ETTEM]}} &
        \bitbox {12}    {\texttt{\et [\ett]}} \\
\end{bytefield}
\end{center}

The data structure of "total calibrated Et in jets" (\htt) quantity [including "towercount" and "minimum bias HF- threshold 0" bits]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,24,25,27,28,31} \\
        \bitbox {4}    {\texttt{MBT0HFM}} &
        \bitbox {3}    {\texttt{spare}} &
        \bitbox {13}    {\texttt{TOWERCOUNT}} &
        \bitbox {12}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

The data structure of "missing Et" (\etm) quantity [including "Asymmetry" ASYMET and "minimum bias HF+ threshold 1" bits]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,19,20,27,28,31} \\
        \bitbox {4}    {\texttt{MBT1HFP}} &
        \bitbox {8}    {\texttt{ASYMET}} &
        \bitbox {8}     {\texttt{$\varphi$}} &
        \bitbox {12}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

The data structure of "missing Ht" (\htm) quantity [including "Asymmetry" ASYMHT and "minimum bias HF- threshold 1" bits]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,19,20,27,28,31} \\
        \bitbox {4}    {\texttt{MBT1HFM}} &
        \bitbox {8}    {\texttt{ASYMHT}} &
        \bitbox {8}     {\texttt{$\varphi$}} &
        \bitbox {12}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

The data structure of "missing Et including HF" (ET$_{miss}^{HF}$) quantity [including "Asymmetry" ASYMETHF and "Centrality" bits (3:0)]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,19,20,27,28,31} \\
        \bitbox {4}    {\small  \texttt{[CENT3:0]}} &
        \bitbox {8}    {\texttt{ASYMETHF}} &
        \bitbox {8}     {\texttt{$\varphi$}} &
        \bitbox {12}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

The data structure of "missing Ht including HF" (HT$_{miss}^{HF}$) quantity [including "Asymmetry" ASYMHTHF and "Centrality" bits (7:4)]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,19,20,27,28,31} \\
        \bitbox {4}    {\small  \texttt{CENT[7:4]}} &
        \bitbox {8}    {\texttt{ASYMHTHF}} &
        \bitbox {8}     {\texttt{$\varphi$}} &
        \bitbox {12}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

\subsubsection{\gmt optical interfaces}
\label{sec:gtl:gmt_optical_interfaces}

The data structure of a muon object (64 bits - bit 34 = charge sign, bit 35 = charge valid, bit 61 is a spare bit, bit 63..62 = impact parameter):

\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, endianness=big, bitwidth=1.2em]{32}
        \bitheader[lsb=32]{32,33,34,35,36,42,43,52,53,60,61,61,62,63} \\
        \bitbox {2}     {\small  \texttt{imp para}}       &
        \bitbox {1}     {\small  \texttt{r}}       &
        \bitbox {8}     {\texttt{unconst.\pt}}       &
        \bitbox {10}    {\texttt{$\varphi$} (out)}
        \bitbox {7}     {\texttt{index bits}}
        \bitbox {2}     {\small  \texttt{ch}}       &
        \bitbox {2}     {\small \texttt{iso}} \\
        [3ex]
        \bitheader{0,9,10,18,19,22,23,31} \\
        \bitbox {9}     {\texttt{$\eta$} (extrapol.)}       &
        \bitbox {4}     {\texttt{qual}}       &
        \bitbox {9}     {\texttt{\pt}}    &
        \bitbox {10}    {\texttt{$\varphi$} (extrapol.)} \\
\end{bytefield}
\end{center}

\clearpage

\subsection{Implementation in firmware}
\label{sec:gtl:implementation_firmware_gtl}

The firmware of \ugtl consists of two main parts:
\begin{itemize}
\item first part which is depending on L1Menus and is created by VHDL Producer
    \begin{itemize}
    \item top-of-hierarchy file (\texttt{gtl\_module.vhd}), which contains:
        \begin{itemize}
        \item pipeline for $\pm$2bx data
        \item instantiations of calculators for differences in $\eta$ and $\varphi$, for $\Delta$R, for all mass types, for two-body pt
        \item instantiations of charge correlation logic of muons
        \item instantiations of conditions
        \item Algorithms logic for 512 Algorithms
        \end{itemize}
    \item as well as a package file (\texttt{gtl\_pkg.vhd}) for declarations. 
    \end{itemize}
\item second part 
    \begin{itemize}
    \item which is a set of VHDL-files for all the modules instantiated in top-of-hierarchy and the modules in the hierarchy. These files, called the "fixed part", are not influenced by VHDL Producer. 
    \end{itemize}
\end{itemize}

Actually 6 AMC board are used to contain 512 Algorithms. Therefore the 512 Algorithms are \textbf{partitioned by VHDL Producer}.
The VHDL Producer for every Trigger Menu (see Figure~\ref{fig:gtl:tme_gtl}) creates VHDL snippets files (\texttt{algo\_index.vhd}, \texttt{gtl\_module\_instances.vhd}, \texttt{gtl\_module\_signals.vhd}, \texttt{ugt\_constants.vhd}), these snippets are inserted into templates for \texttt{gtl\_module.vhd} and \texttt{gtl\_pkg.vhd} during simulation and synthesis.

\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{figures/tme_gtl}
\caption{VHDL file generation by VHDL Producer} 
\label{fig:gtl:tme_gtl}
\end{figure}

The latency of \ugtl is fixed to 5 bunch-crossings,
2 bunch-crossings for the pipeline of $\pm$2bx data (for data with +2bx and +1bx), 2 bunch-crossings for conditions (fixed), also for the conditions requested in the future,
1 bunch-crossing for the logic of Algorithms (See Figure \ref{fig:gtl:gtl_pipeline}).\\

\subsubsection{Top-of-hierarchy module}
\label{sec:gtl:top_module}

The structure of top-of-hierarchy module in this firmware version is different to the former. Calculation of correlation cuts is done outside of conditions. So, calculation of correlation cuts of a certain objects type bunch-crossing combination is instantiated only once in a module. This gives the advantage of using less resources for calculations.

The top-of-hierarchy module (\texttt{gtl\_module.vhd}) contains 
\begin {itemize}
\item pipeline for $\pm$2bx data
\item instantiations of charge correlation logic of muons (generated by VHDL Producer)
\item instantiations of calculators for differences in $\eta$ and $\varphi$, for $\Delta$R, for all mass types, for two-body pt (generated by VHDL Producer)
\item instantiations of conditions (generated by VHDL Producer)
\item boolean logic for Algorithms (generated by VHDL Producer)
\end {itemize}

Listing~\ref{lst:gtl_module_vhd} contains the entity-declaration of the top-of-hierarchy file (\texttt{gtl\_module.vhd}).

%% "automatic generation" of entity-list (see /scripts/extract_entities.sh)
\lstinputlisting[label=lst:gtl_module_vhd,language=VHDL,caption=Entity declaration of \texttt{gtl\_module.vhd}]{interfaces/gtl_module_tpl.vhd}

\subsubsection{Package module}
\label{sec:gtl:package_module}

All the declarations for arrays ('type'), parameters ('constant') and look-up-tables ('constant') used in modules are available in \texttt{gtl\_pkg.vhd} package-file.

\clearpage

\subsection{\ugtl structure}
\label{sec:gtl:mgtl_structure}

\subsubsection{Data $\pm$2bx}
\label{sec:gtl:data_p_m_2bx}

The \ugtl input data flow through a register pipeline of four stages. With those data it is possible to have conditions with objects from different bunch-crossings (within $\pm$2 bunch-crossings), \eg for Correlation conditions.\\
See Figure \ref{fig:gtl:gtl_pipeline} for a scheme of \ugtl pipeline structure. The data "data\_p\_1bx" and "data\_p\_2bx" occur 1 respectively two bunch-crossings after data for a certain bunch-crossing, therefore we got two bunch-crossings of latency from those data. The data "data\_m\_1bx" and "data\_m\_2bx" have no influence on latency, because coming before data for a certain bunch-crossing.
 
\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{figures/gtl_pipeline}
\caption{Scheme of \ugtl pipeline structure} 
\label{fig:gtl:gtl_pipeline}
\end{figure}

\subsubsection{Calculation of correlation cuts}
\label{sec:gtl:delta_r_calculation}

Calculation of correlation cuts is done outside of conditions in this version of Global Trigger firmware. Therefore a new set of VHDL modules is used.

\paragraph{Calculation of differences in $\eta$ and $\varphi$}
\label{sec:gtl:calculation_differences}

Some conditions types namely correlation conditions use differences in $\eta$ and $\varphi$ to make the decision.
Therefore these differences are calculated out of these conditions, because the differences can be used several times in different condition types.
The differences in $\eta$ and $\varphi$ are calculated in bins. These differences in bins are converted to numbers (by LUTs),
which represents values of differences (multiples of units in $\eta$ and $\varphi$).
Differences in $\varphi$ are provided by module \texttt{sub\_phi\_integer\_obj\_vs\_obj.vhd}, which instantiates the module \texttt{sub\_unsigned\_phi.vhd} as many times as the numbers of both objects determine.\\
In the module \texttt{sub\_unsigned\_phi.vhd} a calculation of a difference of two objects is done, both objects must have the same resolution, namely the higher one. The result is the absolute value of the difference.
There are two differences in $\varphi$, one "clockwise" and one "anti-clockwise". For the final result the smaller difference is taken.\\
Differences in $\eta$ are provided by module \texttt{sub\_eta\_integer\_obj\_vs\_obj.vhd}, which instantiates the module \texttt{sub\_signed\_eta.vhd} as many times as the numbers of both objects determine.\\
In the module \texttt{sub\_signed\_eta.vhd} a calculation of a difference of two objects is done with a signed subtraction, because of the Two's Complement notation of $\eta$ values. The result is the absolute value of the difference. 

Because of the different scales of calorimeter and muon objects in $\eta$ and $\varphi$, there are LUTs for conversion the calorimeter bins to muon bins (in \texttt{gtl\_pkg.vhd}:
 e.g. \small{EG\_ETA\_CONV\_2\_MUON\_ETA\_LUT}\normalsize and \small{EG\_PHI\_CONV\_2\_MUON\_PHI\_LUT}\normalsize).\\\\
\textbf{Remark:}\\
The center value of bins are used as reference value for conversion.
The content of \small{EG\_ETA\_CONV\_2\_MUON\_ETA\_LUT}\normalsize is calculated with formular:\\ "converted-calo-eta[bin] = calo-eta[bin] $\times$ 4 + 2",\\
of \small{EG\_PHI\_CONV\_2\_MUON\_PHI\_LUT}\normalsize with formular:\\
"converted-calo-phi[bin] = calo-phi[bin] $\times$ 4 + 2".\\
The conversion calculations are preliminary, others may be proposed.\\\\

Definitions of scales (see Tables \ref{tab:gtl:calo_eta_scale}, \ref{tab:gtl:calo_phi_scale}, \ref{tab:gtl:muon_eta_scale} and \ref{tab:gtl:muon_phi_scale}):
\begin{itemize}
\item Calorimeter objects:
    \begin{itemize}
    \item $\eta$ bin width = $\frac{0.087}{2}$ (bin 0 from 0.0 to $\frac{0.087}{2}$)
    \item $\phi$ bin width = $\frac{2\pi}{144}$ (bin 0 from 0.0 to $\frac{2\pi}{144}$)
    \end{itemize}
\item Muon objects:
    \begin{itemize}
    \item $\eta$ bin width = $\frac{0.087}{8}$ (bin 0 from \small{0.5}$\times\frac{-0.087}{8}$ to \small{0.5}$\times\frac{+0.087}{8}$)
    \item $\phi$ bin width = $\frac{2\pi}{576}$ (bin 0 from 0.0 to $\frac{2\pi}{576}$)
    \end{itemize}
\item \etm, ET$_{miss}^{HF}$ or \htm:
    \begin{itemize}
    \item $\phi$ bin width = $\frac{2\pi}{144}$ (bin 0 from 0.0 to $\frac{2\pi}{144}$)
    \end{itemize}
\end{itemize}

\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{figures/convert_scheme_calo_2_muon_eta_phi}
\caption{Conversion of calorimeter $\eta$ and $\varphi$ to muon scales} 
\label{fig:gtl:convert_scheme_calo_2_muon_eta_phi}
\end{figure}

\paragraph{Calculation of $\cosh(\Delta\eta)$ and $\cos(\Delta\varphi)$}
\label{sec:gtl:calculation_differences}

Some conditions types namely conditions with mass cuts use $\cosh(\Delta\eta)$ and $\cos(\Delta\varphi)$ to calculate mass.\\
The contents of the LUTs for $\cosh(\Delta\eta)$ (\small{obj\_type\_1\_obj\_type\_2\_COSH\_DETA\_LUT}\normalsize, ...) and $\cos(\Delta\varphi)$ (\small{obj\_type\_1\_obj\_type\_2\_COS\_DPHI\_LUT}\normalsize, ...) for invariant mass (formular see \ref{sec:gtl:inv_mass_calculation}) are created by calculating hyperbolic cosine and cosine.
Calculation for calo and esums objects is done by rounding-up at the 3\textsuperscript{rd} position after decimal point, and multiplying by 1000 to get integer values.\footnote{Definition of "\texttt{constant \small{CALO\_INV\_MASS\_COSH\_COS\_PRECISION}\normalsize ..."} in file \texttt{gtl\_pkg.vhd}. Value 1000 from 10\textsuperscript{\tiny{CALO\_INV\_MASS\_COSH\_COS\_PRECISION}}\normalsize}.\\
Calculation for conditions with muon objects is done by rounding-up at the 4\textsuperscript{th} position after decimal point, and multiplying by 10000 to get integer values.\footnote{Definition of "\texttt{constant \small{MUON\_INV\_MASS\_COSH\_COS\_PRECISION}\normalsize"} and other constants (e.g. "\texttt{constant \small{CALO\_MUON\_INV\_MASS\_COSH\_COS\_PRECISION}\normalsize"} in file \texttt{gtl\_pkg.vhd}. Value 10000 from 10\textsuperscript{\tiny{MUON\_INV\_MASS\_COSH\_COS\_PRECISION}}\normalsize.}\\

\paragraph{$\Delta$R calculation}
\label{sec:gtl:delta_r_calculation}

The calculation of \textit{$\Delta$R} of two objects is done with formula in module \texttt{delta\_r\_calc.vhd}:\\ 

$\Delta$$R=\sqrt{(\eta_1-\eta_2)^2+(\varphi_1-\varphi_2)^2}$.\\

In the TME there are two thresholds for $\Delta$R: "greater/equal lower limit" and "less/equal upper limit", given in floating point notation with one position after decimal point.
The comparison in VHDL is done with $\Delta$$R^2$ (no square root in VHDL), thresholds for $\Delta$$R^2$ are provided by VHDL-Producer.

\paragraph{Invariant mass calculation}
\label{sec:gtl:inv_mass_calculation}

The calculation of \textit{invariant mass of two objects} is done with formula in module \texttt{mass\_invariant\_calc.vhd}:\\

M=$\sqrt{2 pt_1  pt_2 (\cosh(\eta_1-\eta_2)-\cos(\varphi_1-\varphi_2))}$.\\

In the TME there are two thresholds for M: "greater/equal lower limit" and "less/equal upper limit", given in GeV (floating point notation) with one position after decimal point in even numbers.\footnote{even numbers to get a precision of one position after decimal point after dividion by 2, because VHDL-Producer calculates thresholds for $\frac{M^2}{2}$, which includes a division by 2.}
The comparison in VHDL is done with $\frac{M^2}{2}$ (no square root in VHDL), thresholds for $\frac{M^2}{2}$ are provided by VHDL-Producer.

\paragraph{Transverse mass calculation}
\label{sec:gtl:transverse_mass_calculation}

The calculation of \textit{transverse mass of two objects} is done with formula in module \texttt{mass\_transverse\_calc.vhd}:\\

M=$\sqrt{2 pt_1 pt_2 (1-\cos(\varphi_1-\varphi_2))}$.\\

In the TME there are two thresholds for M: "greater/equal lower limit" and "less/equal upper limit", given in GeV (floating point notation) with one position after decimal point in even numbers.\\
The comparison in VHDL is done with $\frac{M^2}{2}$ (no square root in VHDL), thresholds for $\frac{M^2}{2}$ are provided by VHDL-Producer.

\paragraph{Two-body pt calculation}
\label{sec:gtl:twobody_pt_calculation}

The calculation of \textit{two-body pt} is done with formula in module \texttt{tbpt\_calc.vhd}:\\

pt=$\sqrt{pt^2_1 + pt^2_2 + 2  pt_1 pt_2 (\cos(\varphi_1) \cos(\varphi_2) + \sin(\varphi_1) \sin(\varphi_2))}$\\

In the TME there is one threshold for pt, given in GeV (floating point notation) with one position after decimal point.
The comparison in VHDL is done with ${pt^2}$ (no square root in VHDL), threshold for ${pt^2}$ is provided by VHDL-Producer.\\
The contents of the LUTs for $\cos(\varphi)$ (\small{xxxx\_COS\_PHI\_LUT}\normalsize) and $\sin(\varphi)$ (\small{xxxx\_SIN\_PHI\_LUT}\normalsize) for two-body pt (formular see \ref{sec:gtl:twobody_pt_calculation}) are created by calculating cosine and sine, rounding-up at the 3\textsuperscript{rd} position after decimal point and multiplying by 1000 to get integer values.\\

\subparagraph{Invariant mass divided by $\Delta$R calculation}
\label{sec:gtl:inv_mass_div_dr_calculation}

The formulas for \textit{invariant mass divided by $\Delta$R of two objects} are:\\

M=$\sqrt{2 pt_1  pt_2 (\cosh(\eta_1-\eta_2)-\cos(\varphi_1-\varphi_2))}$.\\

$\Delta$$R=\sqrt{(\eta_1-\eta_2)^2+(\varphi_1-\varphi_2)^2}$.\\

In the TME there is one threshold for M/$\Delta$R, given in GeV (floating point notation) with one position after decimal point.
The calculation of \textit{invariant mass divided by $\Delta$R of two objects} is done in an own module outside of the condition (\texttt{mass\_div\_dr\_calculator.vhd}) with $\frac{M^2}{2}\times$(1/$\Delta$$R^2$) (no square root in VHDL). This module is instantiated once for every object type bunch-crossing combination.\\  
The values of 1/$\Delta$$R^2$ in VHDL are given by LUTs stored in BRAMs (as ROMs). The addresses of the BRAMs are given by $\Delta\eta$ and $\Delta\varphi$.\\
The calculation of \textit{invariant mass divided by $\Delta$R of two objects} is done in modules \texttt{mass\_invariant\_calc.vhd} and
\texttt{mass\_invariant\_div\_dr\_calc.vhd} (for LUTs and comparison).

\paragraph{Invariant mass calculation for three objects}
\label{sec:gtl:inv_mass_3_obj_calculation}

The calculation of \textit{invariant mass calculation for three objects} is done by calculating the invariant mass for all two object combinations and make a summary of three invariant mass of two object combinations.\\
In the TME there are two thresholds for M: "greater/equal lower limit" and "less/equal upper limit", given in GeV (floating point notation) with one position after decimal point in even numbers.\\
The calculation of \textit{invariant mass calculation for three objects} is done in modules \texttt{mass\_invariant\_calc.vhd} and
\texttt{calo\_calo\_mass\_3\_obj\_condition.vhd} or \texttt{muon\_muon\_mass\_3\_obj\_condition.vhd} (for summary of mass and comparison). 

\paragraph{Muon charge correlation module}
\label{sec:gtl:muon_charge_correlation_module}

For definition of muon charge, see \ref{sec:gtl:muon_conditions}.\\
In the muon charge correlation module (\texttt{muon\_charge\_correlations.vhd}), the charge correlations are made for different muon conditions-types.
The charges of objects (number of objects depends on muon condition type) are compared to get "like sign charge" ("LS") or "opposite sign charge" ("0S"), "LS" means that the charges (charge sign)of objects are the same, "0S" means that at least one object has different  charge than the others. This information is used in all instatiated muon conditions.\\
There is no charge correlation for single type conditions.\\
In all cases the "charge valid" bit of the objects must be set.\\
In TME one can select "LS", "0S" or ignore for charge correlation in muon conditions.\\

% % Table proposed by Vasile Ghete!!!
% Double Muon
% 
% x x : I ignore (charge x = +, -, I)
% + + : LS both positive muons
% - - : LS both negative muons
% I I : LS both muons with the same sign, positive or negative
% + - : OS two muons of opposite sign
% - + : OS idem
% I I : OS idem
% 
% TripleMuon:
% 
% x x x : I  ignore (charge x = +, -, I)
% + + + : LS three muons of positive charge
% - - - : LS three muons of negative charge
% I I I : LS three muons of the same sign (positive or negative)
% + + - : OS a pair plus a positive muon
% + - - : OS a pair plus a negative muon
% + - I : OS a pair plus a negative or positive muon
% 
% QuadMuon
% 
% x x x x : I  ignore (charge x = +, -, I)
% + + + + : LS four muons of positive charge
% - - - - : LS four muons of negative charge
% I I I I : LS four muons of the same sign (positive or negative)
% + + + - : OS a pair plus two positive muons
% + + - - : OS two pairs
% + - - - : OS a pair plus two negative muons
% + - I I : OS a pair plus two negative or positive muons
% 
\begin{table}[ht]
\caption{Muon charge correlation - Double Muon}
\vspace{5mm}
\centering
\begin{tabular}{|c|l|}\hline
\verb|x x| & I ignore (charge x = +, -, I) \\
\verb|+ +| & LS both positive muons \\
\verb|- -| & LS both negative muons \\
\verb|I I| & LS both muons with the same sign, positive or negative \\
\verb|+ -| & OS two muons of opposite sign \\
\verb|- +| & OS idem \\
\verb|I I| & OS idem \\\hline
\end{tabular}
\label{tab:gtl:muon_charge_corr_double}
\end{table}

\begin{table}[ht]
\caption{Muon charge correlation - Triple Muon}
\vspace{5mm}
\centering
\begin{tabular}{|c|l|}\hline
\verb|x x x| & I  ignore (charge x = +, -, I) \\
\verb|+ + +| & LS three muons of positive charge \\
\verb|- - -| & LS three muons of negative charge \\
\verb|I I I| & LS three muons of the same sign (positive or negative) \\
\verb|+ + -| & OS a pair plus a positive muon \\
\verb|+ - -| & OS a pair plus a negative muon \\
\verb|+ - I| & OS a pair plus a negative or positive muon \\\hline
\end{tabular}
\label{tab:gtl:muon_charge_corr_triple}
\end{table}

\begin{table}[ht]
\caption{Muon charge correlation - Quad Muon}
\vspace{5mm}
\centering
\begin{tabular}{|c|l|}\hline
\verb|x x x x| & I  ignore (charge x = +, -, I) \\
\verb|+ + + +| & LS four muons of positive charge \\
\verb|- - - -| & LS four muons of negative charge \\
\verb|I I I I| & LS four muons of the same sign (positive or negative) \\
\verb|+ + + -| & OS a pair plus two positive muons \\
\verb|+ + - -| & OS two pairs \\
\verb|+ - - -| & OS a pair plus two negative muons \\
\verb|+ - I I| & OS a pair plus two negative or positive muons \\\hline
\end{tabular}
\label{tab:gtl:muon_charge_corr_quad}
\end{table}

\clearpage

\subsubsection{Calorimeter conditions}
\label{sec:gtl:calorimeter_conditions}

\paragraph{Calorimeter data}
\label{sec:gtl:calorimeter_data}

The calorimeter trigger processing identifies \textbf{\egamma, jet and tau} objects and \textbf{\esums}.\\

\textbf{\egamma}:\\ Twelve objects are passed to the \ugt for each event.\\
For each selected object, the Calo-Layer2 sends parameters for \et and for position and quality information - encoded in 32 bits: 
\begin{itemize}
\item 9 bits \et, range = 0..255 GeV (HW index = 0..0x1FF), step = 0.5, the highest bin will mark an overflow (HW index 0x1FF): meaning has to be defined
\item 8 (7+1 sign) bits pseudo-rapidity ($\eta$) position, range = -3.0 to 3.0, step = 0.087/2, linear scale, 138 bins (HW index = 0xBC..0x44)
\item 8 bits azimuth angle ($\varphi$) position, range = 2$\pi$, step $\approx$ 2$\pi$/144 (\^=2.5°), 144 bins (HW index = 0..0x8F), HW index starting at 0° (anti-clockwise)
\item 2 bits isolation (meaning not defined yet!) 
\item 5 bits quality and spare (not defined yet!)
\end{itemize}

The data structure of an \egamma object (bits 27..31 are not defined yet, reserved for quality, ...):
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,8,9,16,17,24,25,26,27,31} \\
        \bitbox {5}     {\texttt{qual/spare}} &
        \bitbox {2}     {\texttt{iso}} &
        \bitbox {8}     {\texttt{$\varphi$}}  &
        \bitbox {8}     {\texttt{$\eta$}}  &
        \bitbox {9}     {\texttt{\et}} \\
\end{bytefield}
\end{center}

\textbf{jet}:\\ Twelve objects are passed to the \ugt for each event.\\
For each selected object, the Calo-Layer2 sends parameters: \et, for position and quality information - encoded in 32 bits: 
\begin{itemize}
\item 11 bits \et, range = 0..1023 GeV (HW index = 0..0x7FF), step = 0.5, the highest bin will mark an overflow (HW index 0x7FF): meaning has to be defined
\item 8 (7+1 sign) bits pseudo-rapidity ($\eta$) position, range = -5.0 to 5.0, step = 0.087/2, linear scale, 230 bins (HW index = 0x8E..0x72)
\item 8 bits azimuth angle ($\varphi$) position, range = 2$\pi$, step $\approx$ 2$\pi$/144 (\^=2.5°), 144 bins (HW index = 0..0x8F), HW index starting at 0° (anti-clockwise)
\item 5 bits quality and spare (not defined yet!)
\end{itemize}

The data structure of a jet object (bits 27..31 are not defined yet, reserved for quality, ...):
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,10,11,18,19,26,27,31} \\
        \bitbox {5}     {\texttt{iso/qu/sp}} &
        \bitbox {8}     {\texttt{$\varphi$}}  &
        \bitbox {8}     {\texttt{$\eta$}}  &
        \bitbox {11}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

\textbf{tau}:\\ Twelve objects are passed to the \ugt for each event.\\
For each selected object, the Calo-Layer2 sends parameters for \et and for position and quality information - encoded in 32 bits: 
\begin{itemize}
\item 9 bits \et, range = 0..255 GeV (HW index = 0..0x1FF), step = 0.5, the highest bin will mark an overflow (HW index 0x1FF): meaning has to be defined
\item 8 (7+1 sign) bits pseudo-rapidity ($\eta$) position, range = -3.0 to 3.0, step = 0.087/2, linear scale, 138 bins (HW index = 0xBC..0x44)
\item 8 bits azimuth angle ($\varphi$) position, range = 2$\pi$, step $\approx$ 2$\pi$/144 (\^=2.5°), 144 bins (HW index = 0..0x8F), HW index starting at 0° (anti-clockwise)
\item 2 bits isolation (meaning not defined yet!) 
\item 5 bits quality and spare (not defined yet!)
\end{itemize}

The data structure of a tau object (bits 27..31 are not defined yet, reserved for quality, ...):
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,8,9,16,17,24,25,26,27,31} \\
        \bitbox {5}     {\texttt{qual/spare}} &
        \bitbox {2}     {\texttt{iso}} &
        \bitbox {8}     {\texttt{$\varphi$}}  &
        \bitbox {8}     {\texttt{$\eta$}}  &
        \bitbox {9}     {\texttt{\et}} \\
\end{bytefield}
\end{center}

The representation of the 8 bits (called "hardware index [HW index]") in $\eta$ is expected as Two's Complement notation as shown in Table~\ref{tab:gtl:calo_eta_scale}.\\
 
\begin{table}[htdp]
\caption{$\eta$ scale of \egamma and tau}
\begin{center}
\begin{tabular}{|c|l|c|}\hline
\textbf{HW index}& \textbf{$\eta$ range} & \textbf{$\eta$ bin}\\\hline\hline
0x44 & 68$*$0.087/2 to 69$*$0.087/2 & 68\\\hline
... & ... & ...\\\hline
0x01 & 0.087/2 to 2$*$0.087/2 & 1\\\hline
0x00 & 0 to 0.087/2 & 0\\\hline
0xFF & 0 to -0.087/2 & -1\\\hline
0xFE & -0.087/2 to -2$*$0.087/2 & -2\\\hline
... & ... & ...\\\hline
0xBC & -68$*$0.087/2 to -69$*$0.087/2 & -69\\\hline
\end{tabular}
\end{center}
\label{tab:gtl:calo_eta_scale}
\end{table}

\begin{table}[htdp]
\caption{$\eta$ scale of jet}
\begin{center}
\begin{tabular}{|c|l|c|}\hline
\textbf{HW index}& \textbf{$\eta$ range} & \textbf{$\eta$ bin}\\\hline\hline
0x72 & 114$*$0.087/2 to 115$*$0.087/2 & 114\\\hline
... & ... & ...\\\hline
0x01 & 0.087/2 to 2$*$0.087/2 & 1\\\hline
0x00 & 0 to 0.087/2 & 0\\\hline
0xFF & 0 to -0.087/2 & -1\\\hline
0xFE & -0.087/2 to -2$*$0.087/2 & -2\\\hline
... & ... & ...\\\hline
0x8E & -114$*$0.087/2 to -115$*$0.087/2 & -115\\\hline
\end{tabular}
\end{center}
\label{tab:gtl:calo_eta_scale}
\end{table}

The representation of the 8 bits in $\varphi$ is expected as shown in Table~\ref{tab:gtl:calo_phi_scale}.\\
 
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|l|l|c|}\hline
HW index & $\varphi$ range & $\varphi$ range [degrees] & $\varphi$ bin\\\hline\hline
0x00 & 0 to 2$\pi$/144 & 0 to 2.5 & 0\\\hline
0x01 & 2$\pi$/144 to 2$*$2$\pi$/144 & 2.5 to 5.0 & 1\\\hline
... & ... & ... & ...\\\hline
0x8F & 143$*$2$\pi$/144 to 2$\pi$ & 357.5 to 360 & 143\\\hline
\end{tabular}
\end{center}
\caption{$\varphi$ scale of calorimeter objects}
\label{tab:gtl:calo_phi_scale}
\end{table}

The representation of the 2 bits for isolation (e/$\gamma$ and tau) is expected as shown in Table~\ref{tab:gtl:eg_tau_iso_bits}.\\

\begin{table}[ht]
\caption{Definition of e/$\gamma$ and tau isolation bits}
\vspace{5mm}
\centering
\begin{tabular}{|c|c|}\hline
bits [26..25] & definition \\\hline\hline
00 & not isolated \\
01 & isolated \\
10 & TBD \\
11 & TBD \\\hline
\end{tabular}
\label{tab:gtl:eg_tau_iso_bits}
\end{table}

\clearpage

\paragraph{Calorimeter conditions definition}\label{sec:gtl:calo_cond_def}

A condition consists of calorimeter objects as input data and a set of requirements, which contain the requirements to be complied.

The requirement for calorimeter conditions contains:\\
one threshold for \et, ranges for $\eta$, $\varphi$ LUTs for isolation and differences in $\eta$ and $\varphi$. In addition the selection of the "relative bx" of objects
is done in the requirement.\\
The condition is complied, if every comparison between object parameters and requirements is valid for the following equation:
\begin{itemize}
\item \et greater-equal (or equal) threshold
\item $\eta$ in range
\item $\varphi$ in range
\item isolation as requested (for \egamma and tau)
\end{itemize}
\textit{Additional comparisons for "quality information" could be part of the equation - but not defined yet.}

There are different types of calorimeter conditions implemented, depending of how many objects have to comply the requirements.
\begin{itemize}
\item "Quad objects requirements condition": this condition type consists of requirements for 4 different trigger objects of the same object type. 
For each object the requirements can be different. To fulfill this condition, there must exist at least one set of 4 different objects,
each of which fulfills at least one of the requirements.
\item "Triple objects requirements condition": this condition type consists of requirements for 3 different trigger objects of the same object type. 
For each object the requirements can be different. To fulfill this condition, there must exist at least one set of 3 different objects,
each of which fulfills at least one of the requirements.
\item "Double objects requirements condition": this condition type consists of requirements for 2 different trigger objects of the same object type. 
For each object the requirements can be different. To fulfill this condition, there must exist at least one set of 2 different objects,
each of which fulfills at least one of the requirements.\footnote{"Double objects requirements condition with spatial correlation" not used anymore, replaced by Correlation conditions}
\item "Single object requirement condition": this condition type consists of one requirement for one trigger object of a given object type. 
To fulfill this condition, there must exist at least one object which fulfills the requirement.

\end{itemize}

The selection of the mode of \et-comparator (greater/equal or equal), the \et-threshold-value, ranges for $\eta$ and $\varphi$ set with thresholds, LUTs for isolation and ranges for differences in $\eta$ and $\varphi$ set with thresholds are fixed values given by VHDL Producer for every Trigger Menu.
The objects have to be of same type and same bunch-crossing.

\subparagraph{Calorimeter conditions module}\label{sec:gtl:calo_conditions_module}

The module for conditions with calorimeter objects (\texttt{calo\_conditions.vhd}) instantiates the calorimeter comparators module (\texttt{calo\_comparators.vhd}) as many times as
the numbers of objects and requirements determine. Depending on the condition-type, different and-or-structures of object vs. requirement are selected.
The selection of condition-type and the number of objects is done by parameters in the generic interface list of the module (see Listing~\ref{lst:calo_conditions_vhd},
see also the explanations below).\\
For comparison in $\eta$, $\varphi$ and the differences in $\eta$ and $\varphi$, "window"-comparators are used.\\
In the calorimeter conditions module a cut for two-body pt calculation can be selected (see ~\ref{sec:gtl:twobody_pt_calculation}). Therefore a threshold value for two-body pt is required.\\

%% "automatic generation" of listings (see /scripts/extract_entities.sh)
\lstinputlisting[label=lst:calo_conditions_vhd,language=VHDL,caption=Entity declaration of \texttt{calo\_conditions.vhd}]{interfaces/calo_conditions.vhd}

\medskip
\begin{table}[htdp]
\footnotesize
\begin{center}
\begin{tabular}{l p{.65\columnwidth}}
\toprule
{Item} & {Explanation}\\
\midrule       
\verb|calo_object_slice_1_low| & low value of slice for object 1.\\
\verb|calo_object_slice_1_high| & high value of slice for object 1.\\
\verb|calo_object_slice_2_low| & low value of slice for object 2.\\
\verb|calo_object_slice_2_high| & high value of slice for object 2.\\
\verb|calo_object_slice_3_low| & low value of slice for object 3.\\
\verb|calo_object_slice_3_high| & high value of slice for object 3.\\
\verb|calo_object_slice_4_low| & low value of slice for object 4.\\
\verb|calo_object_slice_4_high| & high value of slice for object 4.\\
\verb|nr_templates| & valid values are 1 (for single), 2 (double), 3 (triple) and 4 (quad) - depending on condition type.\\
\verb|et_ge_mode| & 'mode-selection' for the \et comparator. Valid strings are 'true' and 'false' (type is boolean), 'true' means comparator works on greater/equal, 'false' means equal (for tests only)\\
\verb|obj_type| & valid strings are 'EG\_TYPE', 'JET\_TYPE', and 'TAU\_TYPE'.\\
\verb|et_thresholds| & array of four threshold values for comparison in \et (four thresholds, because of max. 4 requirements).\\
\verb|nr_eta_windows| & array of four integer values for number of $\eta$ cuts.\\
\verb|eta_w1_upper_limits| & array of four "upper limits" of "window"-comparator 1 for $\eta$.\\
\verb|eta_w1_lower_limits| & array of four "lower limits" of "window"-comparator 1 for $\eta$.\\
\verb|eta_w2_upper_limits| & array of four "upper limits" of "window"-comparator 2 for $\eta$.\\
\verb|eta_w2_lower_limits| & array of four "lower limits" of "window"-comparator 2 for $\eta$.\\
\verb|eta_w3_upper_limits| & array of four "upper limits" of "window"-comparator 3 for $\eta$.\\
\verb|eta_w3_lower_limits| & array of four "lower limits" of "window"-comparator 3 for $\eta$.\\
\verb|eta_w4_upper_limits| & array of four "upper limits" of "window"-comparator 4 for $\eta$.\\
\verb|eta_w4_lower_limits| & array of four "lower limits" of "window"-comparator 4 for $\eta$.\\
\verb|eta_w5_upper_limits| & array of four "upper limits" of "window"-comparator 5 for $\eta$.\\
\verb|eta_w5_lower_limits| & array of four "lower limits" of "window"-comparator 5 for $\eta$.\\
\verb|phi_full_range| & array of four boolean to set full range of $\varphi$.\\
\verb|phi_w1_upper_limits| & array of four "upper limits" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w1_lower_limits| & array of four "lower limits" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w2_ignore| & array of four boolean to ignore "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_upper_limits| & array of four "upper limits" of "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_lower_limits| & array of four "lower limits" of "window"-comparator 2 for $\varphi$.\\
\verb|iso_luts| &  array of four LUTs for comparison of isolation.\\
\verb|twobody_pt_cut| & valid strings are 'true' and 'false' (type is boolean).\\
\verb|pt_width| & vector length of pt value for two-body pt.\\
\verb|pt_sq_threshold_vector| & hex value for threshold of two-body pt comparison (value for pt square).\\
\verb|sin_cos_width| & vector length of sine and cosine.\\
\verb|pt_sq_sin_cos_precision| & precision of sine and cosine calculation in LUTs.\\
\verb|clk| & clock input (LHC clock).\\
\verb|data_i| & data, structure defined in \texttt{obj\_type}.\\
\verb|condition_o| & output of condition (routed to Algorithms logic, see \ref{sec:gtl:algorithms_logic}).\\
\verb|pt| & pt value for two-body pt.\\
\verb|cos_phi_integer| & interger value of cosine for two-body pt.\\
\verb|sin_phi_integer| & interger value of sine for two-body pt.\\
\bottomrule
\end{tabular}
\end{center}
\caption{Explanation of Listing~\ref{lst:calo_conditions_vhd}}
\label{tab:gtl:explanation_calo_conditions_vhd}
\end{table}

\clearpage

\subparagraph{Calorimeter Overlap Remover conditions module}\label{sec:gtl:calo_conditions_orm_module}
The Calorimeter Overlap Remover conditions consits of a Calorimeter condition (\ref{sec:gtl:calo_conditions_module}) and a single condition for a different calo object type. One or more correlation cut(s) ($\Delta\eta$, $\Delta\varphi$ and $\Delta$R - \ref{sec:gtl:correlation_conditions}) for overlap removal is required between different calo object types.
Overlap Remover conditions \texttt{calo\_conditions\_orm.vhd} are implemented only for calo object types.

\subparagraph{Calorimeter conditions module - template for VHDL-Producer}
See in Chapter \ref{sec:gtl:calo_conditions_tme} and in Listing~\ref{lst:instance_calo_condition_vhd} for a VHDL-template for VHDL-Producer of
instantiating a calorimeter condition (\texttt{calo\_conditions.vhd}).\\

\subparagraph{Calorimeter comparators module}\label{sec:gtl:calo_comp_module}
A comparator between the energy (\et) and a threshold (et\_threshold) and a comparison in $\eta$ with five "window"-comparators and $\varphi$ with two "window"-comparators
is done in this basic module. The values for \et threshold, the 'mode-selection' for the \et comparator and the "limits" of the "window"-comparators 
is given in the generic interface list of the module. Additionally the data-structure of input data (data\_i in port interface list) is provided
as a record in this list. The output signal of the module is in high state, if all comparisons are true.\\
The comparison in $\eta$ is done with five "window"-comparators, so one gets max. five ranges for $\eta$. The $\eta$ value (HW index) has a Two's Complement notation, the comparisons is done signed. Number of windows is given for $\eta$.\\
The comparison in $\varphi$ is done with two "window"-comparators, so one gets two ranges for $\varphi$. The comparisons is done unsigned. There are two flags, one for "full-range" and one for "ignore-second-window" for the selection of the ranges.\\
There are two cases how the limits of one "window"-comparator could be set (see also Figure~\ref{fig:gtl:phi_windows_comparator} and Listing~\ref{lst:phi_window_comparator_vhd}):
\begin{itemize}
\item Upper limit is less than lower limit => $\varphi$ range between the limits, including the $\varphi$ bin with value = 0 (HW index).
\item Upper limit is greater/equal than lower limit => $\varphi$ range between the limits, not including the $\varphi$ bin with value = 0 (HW index).
\end{itemize}
The comparison of isolation (for \egamma and tau) is done with LUTs.
\begin{lstlisting}[label=lst:phi_window_comparator_vhd,float=here,caption=VHDL code of "window"-comparator in $\varphi$,captionpos=t]
    phi_comp_w1 <= '1' when phi_w1_upper_limit < phi_w1_lower_limit and
                    (phi <= phi_w1_upper_limit or phi >= phi_w1_lower_limit) else
                   '1' when phi_w1_upper_limit >= phi_w1_lower_limit and
                    (phi <= phi_w1_upper_limit and phi >= phi_w1_lower_limit)
                    else '0';
\end{lstlisting}

The values of $\eta$ and $\varphi$ have to be inside of only one of the required ranges ("or").

The comparison of isolation (for \egamma and tau) is done with LUTs (see Table~\ref{tab:gtl:calo_lut_iso}).
Only the least significant 4 bits of LUT are used, because currently 2 isolation bits are defined. 

\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|p{.4\columnwidth}|}\hline
LUT content (16 bits) & isolation bits [26..25] & trigger \\\hline\hline
X"0" & xx & no trigger\\\hline
X"1" & 00 & trigger on isolation bits = 00\\\hline
X"2" & 01 & trigger on isolation bits = 01\\\hline
X"3" & 00 or 01 & trigger on isolation bits = 00 or 01\\\hline
X"4" & 10 & trigger on isolation bits = 10\\\hline
X"5" & 00 or 10 & trigger on isolation bits = 00 or 10\\\hline
X"6" & 01 or 10 & trigger on isolation bits = 01 or 10\\\hline
X"7" & 00 or 01 or 10 & trigger on isolation bits = 00 or 01 or 10\\\hline
X"8" & 11 & trigger on isolation bits = 11\\\hline
X"9" & 00 or 11 & trigger on isolation bits = 00 or 11\\\hline
X"A" & 01 or 11 & trigger on isolation bits = 01 or 11\\\hline
X"B" & 00 or 01 or 11 & trigger on isolation bits = 00 or 01 or 11\\\hline
X"C" & 10 or 11 & trigger on isolation bits = 10 or 11\\\hline
X"D" & 00 or 10 or 11 & trigger on isolation bits = 00 or 10 or 11\\\hline
X"E" & 01 or 10 or 11 & trigger on isolation bits = 01 or 10 or 11\\\hline
X"F" & 00 or 01 or 10 or 11 & trigger on isolation bits = 00 or 01 or 10 or 11 (= "ignore" isolation)\\\hline
\end{tabular}
\end{center}
\caption{LUT contents for isolation comparison of \egamma and tau objects}
\label{tab:gtl:calo_lut_iso}
\end{table}

\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{figures/phi_windows_comparator}
\caption{Setting the limits for "window"-comparators for $\varphi$} 
\label{fig:gtl:phi_windows_comparator}
\end{figure}

\clearpage

\subsubsection{Energy sum quantities conditions}
\label{sec:gtl:esums_conditions}

\textbf{\esums}:\\ Consists of following quantities (naming convention see \ref{sec:glossary}):
\begin{itemize}
\item \textbf{\ett}
\item \textbf{\htt}
\item \textbf{\etm}
\item \textbf{\htm}
\item \textbf{ETTEM}
\item \textbf{ET$_{miss}^{HF}$}
\item \textbf{HT$_{miss}^{HF}$}
\item \textbf{ASYMET}
\item \textbf{ASYMHT}
\item \textbf{ASYMETHF}
\item \textbf{ASYMHTHF}
\item \textbf{CENT0}
\item \textbf..
\item \textbf{CENT7}
\end{itemize}

\paragraph{Energy sum quantities data}
Calo-Layer2 sends 6 frames (each 32 bits) with Energy sum quantities containing the following information:
\begin{itemize}
\item \et, 12 bits, range = 0..2047 GeV (HW index = 0..0xFFF), step = 0.5, the highest bin will mark an overflow (HW index 0xFFF): meaning has to be defined
\item azimuth angle ($\varphi$) position, 8 bits, range = 2$\pi$, step $\approx$ 2$\pi$/144 (\^=2.5°), 144 bins (HW index = 0..0x8F), HW index starting at 0° (anti-clockwise)
\item "Towercount", 13 bits, range = 0..8191
\item "Minimum bias", 4 bits, range = 0..15
\item "Asymmetry", 8 bits, range = 0..255 (used 0..100)
\item "Centrality", 8 bits, used as signals
\end{itemize}

Frame0: The data structure of "total Et" (\ett) quantity [including "total Et from ECAL only" (ETTEM) and "minimum bias HF+ threshold 0" bits]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,23,24,27,28,31} \\
        \bitbox {4}    {\texttt{MBT0HFP}} &
        \bitbox {4}    {\texttt{spare}} &
        \bitbox {12}    {\texttt{\et [ETTEM]}} &
        \bitbox {12}    {\texttt{\et [\ett]}} \\
\end{bytefield}
\end{center}

Frame1: The data structure of "total calibrated Et in jets" (\htt) quantity [including "towercount" and "minimum bias HF- threshold 0" bits]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,24,25,27,28,31} \\
        \bitbox {4}    {\texttt{MBT0HFM}} &
        \bitbox {3}    {\texttt{spare}} &
        \bitbox {13}    {\texttt{TOWERCOUNT}} &
        \bitbox {12}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

Frame2: The data structure of "missing Et" (\etm) quantity [including "Asymmetry" ASYMET and "minimum bias HF+ threshold 1" bits]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,19,20,27,28,31} \\
        \bitbox {4}    {\texttt{MBT1HFP}} &
        \bitbox {8}    {\texttt{ASYMET}} &
        \bitbox {8}     {\texttt{$\varphi$}} &
        \bitbox {12}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

Frame3: The data structure of "missing Ht" (\htm) quantity [including "Asymmetry" ASYMHT and "minimum bias HF- threshold 1" bits]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,19,20,27,28,31} \\
        \bitbox {4}    {\texttt{MBT1HFM}} &
        \bitbox {8}    {\texttt{ASYMHT}} &
        \bitbox {8}     {\texttt{$\varphi$}} &
        \bitbox {12}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

Frame4: The data structure of "missing Et including HF" (ET$_{miss}^{HF}$) quantity [including "Asymmetry" ASYMETHF and "Centrality" bits (3:0)]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,19,20,27,28,31} \\
        \bitbox {4}    {\small \texttt{CENT[3:0]}} &
        \bitbox {8}    {\texttt{ASYMETHF}} &
        \bitbox {8}     {\texttt{$\varphi$}} &
        \bitbox {12}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

Frame5: The data structure of "missing Ht including HF" (HT$_{miss}^{HF}$) quantity [including "Asymmetry" ASYMHTHF and "Centrality" bits (7:4)]:
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, bitwidth=1.2em, endianness=big]{32}
        \bitheader{0,11,12,19,20,27,28,31} \\
        \bitbox {4}    {\small \texttt{CENT[7:4]}} &
        \bitbox {8}    {\texttt{ASYMHTHF}} &
        \bitbox {8}     {\texttt{$\varphi$}} &
        \bitbox {12}    {\texttt{\et}} \\
\end{bytefield}
\end{center}

\paragraph{Energy sum quantities conditions module (including Asymmetry conditions)}

For the entity-declaration of \texttt{esums\_conditions.vhd}, see Listing~\ref{lst:esums_conditions_vhd}.

% "automatic generation" of listings (see /scripts/extract_entities.sh)
%% REMARK: HB 2015-04-29: esums_conditions.vhd is not in ../firmware/gt_mp7/trunk/src and (scripts/extract_entities.sh) now, so interfaces/esums_conditions.vhd was copied and edited by hand.
\lstinputlisting[label=lst:esums_conditions_vhd,language=VHDL,caption=Entity declaration of \texttt{esums\_conditions.vhd}]{interfaces/esums_conditions.vhd}

\medskip
\begin{table}[htdp]
\footnotesize
\begin{center}
\begin{tabular}{l p{.7\columnwidth}}
\toprule
{Item} & {Explanation}\\
\midrule       
\verb|et_ge_mode| & 'mode-selection' for the \et comparator. Valid strings are 'true' and 'false' (type is boolean), 'true' means comparator works on greater/equal, 'false' means equal (for tests only)\\
\verb|obj_type| &  valid strings are 'ETT\_TYPE', 'HTT\_TYPE', 'ETM\_TYPE', 'HTM\_TYPE' and 'ETMHF\_TYPE'.\\
\verb|et_threshold| & threshold value for comparison in \et. The size of the std\_logic\_vector depends on the number of \et bits.\\
\verb|phi_full_range| & boolean to set full range of $\varphi$.\\
\verb|phi_w1_upper_limits| & "upper limit" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w1_lower_limits| & "lower limit" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w2_ignore| & boolean to ignore "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_upper_limits| & "upper limit" of "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_lower_limits| & "lower limit" of "window"-comparator 2 for $\varphi$.\\
\verb|clk| & clock input (LHC clock).\\
\verb|data_i| & input data, structure defined in \texttt{obj\_type}.\\
\verb|condition_o| & output of condition (routed to Algorithms logic, see \ref{sec:gtl:algorithms_logic}).\\
\bottomrule
\end{tabular}
\end{center}
\caption{Explanation of Listing~\ref{lst:esums_conditions_vhd}}
\label{tab:gtl:explanation_esums_conditions_vhd}
\end{table}

A comparator between \et and a threshold (et\_threshold) and, depending on object type, a comparison in $\varphi$ with 
two "window"-comparators is done in this module. 
The value for \et threshold, the 'mode-selection' for the \et comparator and the limits for the "window"-comparators are given in the generic interface list of the module.
The selection whether a comparison in $\varphi$ is part of the condition is done with the value of the generic parameter 'obj\_type' 
('ETM\_TYPE', 'ETMHF\_TYPE', 'HTM\_TYPE' and 'HTMHF\_TYPE' force a comparison).
The comparison in $\varphi$ is done in the same way as for calorimeter conditions (see \ref{sec:gtl:calo_comp_module}).
Additionally the data-structure of input data (data\_i in port interface list) is provided
as a record in this list. The output signal of the module is in high state, if all comparisons are true.\\
Data for Asymmetry trigger are received on 4 frames on bits 27..20 (8 bits). For every type a comparision with an 8-bit threshold (greater-equal [or equal]) is done.
Asymmetry data are interpreted as counts.

\paragraph{Energy sum quantities conditions module - template for VHDL-Producer}
A VHDL-template for VHDL-Producer of instantiating \texttt{esums\_conditions.vhd} is given below (see Listing~\ref{lst:instance_esums_condition_vhd}).\\

\subsubsection{Minimum bias trigger conditions}
\label{sec:gtl:min_bias_conditions}

Data for Minimum bias trigger are received on the 4 MSBs of 4 frames used for Energy sum quantities (see \ref{sec:gtl:esums_conditions}). 

\begin{itemize}
\item MBT0HFP: "minimum bias HF+ threshold 0" bits
\item MBT0HFM: "minimum bias HF- threshold 0" bits
\item MBT1HFP: "minimum bias HF+ threshold 1" bits
\item MBT1HFM: "minimum bias HF- threshold 1" bits
\end{itemize}

In the min\_bias\_hf\_conditions.vhd module there is a comparision with a 4-bit threshold (greater-equal [or equal]).

\subsubsection{Towercount condition}
\label{sec:gtl:towercount_cond}

Data for Towercount trigger (number of firing HCAL towers) are received on frame \htt (see \ref{sec:gtl:esums_conditions}) on bits 24..12 (13 bits) of \htt data structure. 
In the towercount\_condition.vhd module there is a comparision with a 13-bit threshold (greater-equal [or equal]).

\subsubsection{Centrality condition}
\label{sec:gtl:centrality_cond}

Centrality bits used as a signals for triggers (similar to external signals).

\subsubsection{Muon conditions}
\label{sec:gtl:muon_conditions}

\paragraph{Muon data}
\label{sec:gtl:muon_data}
Eight Muon objects are provided by \gmt. One Muon object has a 64 bits data structure with parameters for \pt, for position, charge, quality and isolation information: 
\begin{itemize}
\item 10 bits azimuth angle ($\varphi$) position, range = 2$\pi$, step $\approx$ 2$\pi$/576 (\^=0.625°), 576 bins (HW index = 0..0x23F), HW index starting at 0° (anti-clockwise)
\item 9 bits \pt, range = 0..255 GeV (HW index = 0..0x1FF), step = 0.5, the highest bin will mark an overflow (HW index 0x1FF): meaning has to be defined
\item 4 bits quality, 16 types for quality (meaning not defined yet!)
\item 9 (8+1 sign) bits pseudo-rapidity ($\eta$) position, range = -2.45 to 2.45, step = 0.087/8, linear scale, 452 bins (-225..225, HW index = 0x11F..0x0E1)
\item 2 bits isolation, 4 types for isolation (meaning not defined yet!)
\item 1 bit charge sign, charge sign = '0' means "positive" charge, charge sign = '1' means "negative" charge
\item 1 bit charge valid (='1' means "valid")
\item 7 index bits
\item 10 bits azimuth angle ($\varphi$) position, raw data
\item 8 bits unconstrained \pt, range = 0..255 GeV (HW index = 0..0xFF), step = 1.0, the highest bin will mark an overflow (HW index 0xFF)
\item 1 spare bit
\item 2 bits impact parameter
\end{itemize}

The data structure of a muon object (64 bits - bit 34 = charge sign, bit 35 = charge valid, bit 61 is a spare bit, bit 63..62 = impact parameter):
\begin{center}
\begin{bytefield}[boxformatting={\centering\itshape}, endianness=big, bitwidth=1.2em]{32}
        \bitheader[lsb=32]{32,33,34,35,36,42,43,52,53,60,61,61,62,63} \\
        \bitbox {2}     {\small  \texttt{imp para}}       &
        \bitbox {1}     {\small  \texttt{r}}       &
        \bitbox {8}     {\texttt{unconst.\pt}}       &
        \bitbox {10}    {\texttt{$\varphi$} (out)}
        \bitbox {7}     {\texttt{index bits}}
        \bitbox {2}     {\small  \texttt{ch}}       &
        \bitbox {2}     {\small \texttt{iso}} \\
        [3ex]
        \bitheader{0,9,10,18,19,22,23,31} \\
        \bitbox {9}     {\texttt{$\eta$} (extrapol.)}       &
        \bitbox {4}     {\texttt{qual}}       &
        \bitbox {9}     {\texttt{\pt}}    &
        \bitbox {10}    {\texttt{$\varphi$} (extrapol.)} \\
\end{bytefield}
\end{center}

The representation of the 9 bits (called "hardware index [HW index]") in $\eta$ is expected as Two's Complement notation as shown in Table~\ref{tab:gtl:muon_eta_scale}.\\
The central value of the bin 0 (-0.010875/2 to +0.010875/2) = 0.0, the left edge of the bins will range from $-255 \times 0.010875 - 0.010875/2 = -2.7785625$ to $+255 \times 0.010875 - 0.010875/2 = 2.7676875$.
The central value of the bins will range between $\pm 2.773125$ . The physical $\eta$ range of the muon detectors is about $\pm2.45$, so that not all possible $\eta$ bins will be used.\\ 
 
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|l|c|}\hline
HW index & $\eta$ range & $\eta$ bin\\\hline\hline
0x0E1 & 224.5$*$0.087/8 to 225.5$*$0.087/8 & 225\\\hline
0x0E0 & 223.5$*$0.087/8 to 224.5$*$0.087/8 & 224\\\hline
... & ... & ...\\\hline
0x001 & 0.5$*$0.087/8 to 1.5$*$0.087/8 & 1\\\hline
0x000 & 0.5$*$-0.087/8 to 0.5$*$0.087/8 & 0\\\hline
0x1FF & 0.5$*$-0.087/8 to 1.5$*$-0.087/8 & -1\\\hline
0x1FE & 1.5$*$-0.087/8 to -2.5$*$0.087/8 & -2\\\hline
... & ... & ...\\\hline
0x11F & -224.5$*$0.087/8 to -225.5$*$0.087/8 & -225\\\hline
\end{tabular}
\end{center}
\caption{$\eta$ scale of muon objects}
\label{tab:gtl:muon_eta_scale}
\end{table}

The representation of the 10 bits in $\varphi$ is expected as shown in Table~\ref{tab:gtl:muon_phi_scale}.\\
 
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|l|l|c|}\hline
HW index & $\varphi$ range & $\varphi$ range [degrees] & $\varphi$ bin\\\hline\hline
0x000 & 0 to 2$\pi$/576 & 0 to 0.625 & 0\\\hline
0x001 & 2$\pi$/576 to 2$*$2$\pi$/576 & 0.625 to 1.250 & 1\\\hline
... & ... & ... & ...\\\hline
0x23F & 575$*$2$\pi$/576 to 2$\pi$ & 359.375 to 360 & 575\\\hline
\end{tabular}
\end{center}
\caption{$\varphi$ scale of muon objects}
\label{tab:gtl:muon_phi_scale}
\end{table}

The representation of the 4 bits for quality is expected as shown in Table~\ref{tab:gtl:muon_quality_bits}.\\
 
\begin{table}[ht]
\caption{Definition of muon quality bits}
\vspace{5mm}
\centering
\begin{tabular}{|c|c|}\hline
bits [22..19] & definition \\\hline\hline
0000 & quality "level 0" \\
0001 & quality "level 1" \\
0010 & quality "level 2" \\
0011 & quality "level 3" \\
0100 & quality "level 4" \\
0101 & quality "level 5" \\
0110 & quality "level 6" \\
0111 & quality "level 7" \\
1000 & quality "level 8" \\
1001 & quality "level 9" \\
1010 & quality "level 10" \\
1011 & quality "level 11" \\
1100 & quality "level 12" \\
1101 & quality "level 13" \\
1110 & quality "level 14" \\
1111 & quality "level 15" \\\hline
\end{tabular}
\label{tab:gtl:muon_quality_bits}
\end{table}

The representation of the 2 bits for isolation is expected as shown in Table~\ref{tab:gtl:muon_iso_bits}.\\
 
\begin{table}[ht]
\caption{Definition of muon isolation bits}
\vspace{5mm}
\centering
\begin{tabular}{|c|c|}\hline
bits [33..32] & definition \\\hline\hline
00 & not isolated \\
01 & isolated \\
10 & TBD \\
11 & TBD \\\hline
\end{tabular}
\label{tab:gtl:muon_iso_bits}
\end{table}

The representation of the 2 bits for impact parameter is expected as shown in Table~\ref{tab:gtl:muon_iso_bits}.\\
 
\begin{table}[ht]
\caption{Definition of muon impact parameter bits}
\vspace{5mm}
\centering
\begin{tabular}{|c|c|}\hline
bits [63..62] & definition \\\hline\hline
00 & TBD \\
01 & TBD \\
10 & TBD \\
11 & TBD \\\hline
\end{tabular}
\label{tab:gtl:muon_iso_bits}
\end{table}

\clearpage

\paragraph{Muon conditions definition}\label{sec:gtl:muon_cond_def}

A condition consists of input-data and a set of requirements, which contain the requirements to be complied.

The requirement for muon conditions contains:\\
a threshold for \pt, a threshold for unconstrained \pt, ranges for $\eta$ and $\varphi$, a LUT for quality, a LUT for isolation, 
a requsted charge.
The condition is complied, if every comparison between object parameters and requirements is valid for the following equation:
\begin{itemize}
\item \pt greater-equal (or equal) threshold
\item unconstrained \pt greater-equal (or equal) threshold
\item $\eta$ in range
\item $\varphi$ in range
\item requested charge 
\item quality LUT
\item iso LUT
\end{itemize}

There are different types of calorimeter conditions implemented, depending of how many objects have to comply the requirements.
\begin{itemize}
\item "Quad objects requirements condition": this condition type consists of requirements for 4 different trigger objects of the same object type. 
For each object the requirements can be different. To fulfill this condition, there must exist at least one set of 4 different objects,
each of which fulfills at least one of the requirements.
\item "Triple objects requirements condition": this condition type consists of requirements for 3 different trigger objects of the same object type. 
For each object the requirements can be different. To fulfill this condition, there must exist at least one set of 3 different objects,
each of which fulfills at least one of the requirements.
\item "Double objects requirements condition": this condition type consists of requirements for 2 different trigger objects of the same object type. 
For each object the requirements can be different. To fulfill this condition, there must exist at least one set of 2 different objects,
each of which fulfills at least one of the requirements.\footnote{"Double objects requirements condition with spatial correlation" not used anymore, replaced by Correlation conditions}
\item "Single object requirement condition": this condition type consists of one requirement for one trigger object of a given object type. 
To fulfill this condition, there must exist at least one object which fulfills the requirement.

\end{itemize}

In addition requested charge correlation must be matched (except for "Single object requirement condition", there is no charge correlation).
The calculation of charge correlations is done in an own module in the top-of-hierarchy module (\texttt{gtl\_module.vhd}).\\

\subparagraph{Muon conditions module}
A module for conditions with muon objects (\texttt{muon\_conditions.vhd}) instantiates the muon comparators module (\texttt{muon\_comparators.vhd}) as many times as
the numbers of objects and requirements determine. Depending on the condition-type different and-or-structures of object vs. requirement are selected.
The selection of condition-type and the number of objects is done by parameters in the generic interface list of the module
(see the following VHDL entity definition in Listing~\ref{lst:muon_conditions_vhd}).\\

\clearpage
%% "automatic generation" of listings (see /scripts/extract_entities.sh)
\lstinputlisting[label=lst:muon_conditions_vhd,language=VHDL,caption=Entity declaration of \texttt{muon\_conditions.vhd}]{interfaces/muon_conditions.vhd}

\clearpage

\begin{longtable}{>{\footnotesize}l >{\footnotesize}p{.65\columnwidth}}
\caption{Explanation of Listing~\ref{lst:muon_conditions_vhd}}\\
\hline 
{Item} & {Explanation}\\
\hline 
\endhead
\verb|muon_object_slice_1_low| & low value of slice for object 1.\\
\verb|muon_object_slice_1_high| & high value of slice for object 1.\\
\verb|muon_object_slice_2_low| & low value of slice for object 2.\\
\verb|muon_object_slice_2_high| & high value of slice for object 2.\\
\verb|muon_object_slice_3_low| & low value of slice for object 3.\\
\verb|muon_object_slice_3_high| & high value of slice for object 3.\\
\verb|muon_object_slice_4_low| & low value of slice for object 4.\\
\verb|muon_object_slice_4_high| & high value of slice for object 4.\\
\verb|nr_templates| & number of requirements, selector of condition-type. Valid values are 1, 2, 3 and 4.\\
\verb|pt_ge_mode| & 'mode-selection' for the \pt comparator. Valid strings are 'true' and 'false' (type is boolean), 'true' means comparator works on greater/equal, 'false' means equal (for tests only)\\
\verb|pt_thresholds| & array of four threshold values for comparison in pt (four threshold, because of max. 4 requirements).\\
\verb|nr_eta_windows| & array of four integer values for number of $\eta$ cuts.\\
\verb|eta_w1_upper_limits| & array of four "upper limits" of "window"-comparator 1 for $\eta$.\\
\verb|eta_w1_lower_limits| & array of four "lower limits" of "window"-comparator 1 for $\eta$.\\
\verb|eta_w2_upper_limits| & array of four "upper limits" of "window"-comparator 2 for $\eta$.\\
\verb|eta_w2_lower_limits| & array of four "lower limits" of "window"-comparator 2 for $\eta$.\\
\verb|eta_w3_upper_limits| & array of four "upper limits" of "window"-comparator 3 for $\eta$.\\
\verb|eta_w3_lower_limits| & array of four "lower limits" of "window"-comparator 3 for $\eta$.\\
\verb|eta_w4_upper_limits| & array of four "upper limits" of "window"-comparator 4 for $\eta$.\\
\verb|eta_w4_lower_limits| & array of four "lower limits" of "window"-comparator 4 for $\eta$.\\
\verb|eta_w5_upper_limits| & array of four "upper limits" of "window"-comparator 5 for $\eta$.\\
\verb|eta_w5_lower_limits| & array of four "lower limits" of "window"-comparator 5 for $\eta$.\\
\verb|phi_full_range| & array of four boolean to set full range of $\varphi$.\\
\verb|phi_w1_upper_limits| & array of four "upper limits" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w1_lower_limits| & array of four "lower limits" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w2_ignore| & array of four boolean to ignore "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_upper_limits| & array of four "upper limits" of "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_lower_limits| & array of four "lower limits" of "window"-comparator 2 for $\varphi$.\\
\verb|requested_charges| & array of four strings for requested charge ("pos" means "positive charge", "neg" means "negative charge" and "ign" means "ignore charge").\\
\verb|qual_luts| & array of four LUTs (16 bits) for quality.\\
\verb|iso_luts| & array of four LUTs (4 bits) for isolation.\\
\verb|upt_cuts| & array of four boolean for using unconstrained \pt cuts.\\
\verb|upt_upper_limits| & array of four "upper limits" of unconstrained \pt.\\
\verb|upt_lower_limits| & array of four "lower limits" of unconstrained \pt.\\
\verb|ip_luts| & array of four LUTs (4 bits) for impact parameter.\\
\verb|requested_charge_correlation| & string (2 characters) for requested charge correlation ("ls" means "like sign", "os" means "opposite sign" or "ig" means "ignore").\\
\verb|twobody_pt_cut| & valid strings are 'true' and 'false' (type is boolean).\\
\verb|pt_width| & vector length of pt value for two-body pt.\\
\verb|pt_sq_threshold_vector| & hex value for threshold of two-body pt comparison (value for pt square).\\
\verb|sin_cos_width| & vector length of sine and cosine.\\
\verb|pt_sq_sin_cos_precision| & precision of sine and cosine calculation in LUTs.\\
\verb|lhc_clk| & clock input (LHC clock).\\
\verb|data_i| & input data, structure defined in \texttt{d\_s\_i}.\\
\verb|condition_o| & output of condition (routed to Algorithms logic, see \ref{sec:gtl:algorithms_logic}).\\
\verb|ls_charcorr_double| & array of "like sign" charge correlation for double condition.\\
\verb|os_charcorr_double| & array of "opposite sign" charge correlation for double condition.\\
\verb|ls_charcorr_triple| & array of "like sign" charge correlation for triple condition.\\
\verb|os_charcorr_triple| & array of "opposite sign" charge correlation for triple condition.\\
\verb|ls_charcorr_quad| & array of "like sign" charge correlation for quad condition.\\
\verb|os_charcorr_quad| & array of "opposite sign" charge correlation for quad condition.\\
\verb|pt| & pt value for two-body pt.\\
\verb|cos_phi_integer| & interger value of cosine for two-body pt.\\
\verb|sin_phi_integer| & interger value of sine for two-body pt.\\
\hline 
\label{tab:gtl:explanation_muon_conditions_vhd}
\end{longtable}

\clearpage

\subparagraph{Muon conditions module - template for VHDL-Producer}
See in Chapter \ref{sec:gtl:templates_tme} and in Listing~\ref{lst:instance_muon_condition_vhd}) for a VHDL-template for VHDL-Producer of
instantiating a muon condition (\texttt{muon\_conditions.vhd}).\\

\subparagraph{Muon comparators module}\label{sec:gtl:muon_comp_module}
A comparator between \pt and a threshold (pt\_threshold), a comparator between unconstrained \pt and a threshold (upt\_threshold), a comparison in $\eta$ with five "window"-comparators and $\varphi$ with two "window"-comparators, a comparison of quality with LUT, a comparison of isolation with LUT and a comparison of the requested charge is done in this basic module. The values for \pt threshold, unconstrained \pt threshold, the 'mode-selection' for the \pt comparator, the "limits" of the "window"-comparators, the quality LUTs, the isolation LUTs and the requested charge is given in the generic interface list of the module.
Additionally the data-structure of input data (data\_i in port interface list) is provided as a record in this list. The output signal of the module is in high state, if all comparisons are true.\\
The comparison in $\eta$ is done with five "window"-comparators, so one gets max. five ranges for $\eta$. The $\eta$ value (HW index) has a Two's Complement notation, the comparisons is done signed. Number of windows is given for $\eta$.\\
The comparison in $\varphi$ is done with two "window"-comparators, so one gets two ranges for $\varphi$. The comparisons is done unsigned. There are two flags, one for "full-range" and one for "ignore-second-window" for the selection of the ranges.\\
There are two cases how the limits of one "window"-comparator could be set (see also Figure~\ref{fig:gtl:phi_windows_comparator} and Listing~\ref{lst:phi_window_comparator_vhd}):
\begin{itemize}
\item Upper limit is less than lower limit => $\varphi$ range between the limits, including the $\varphi$ bin with value = 0 (HW index).
\item Upper limit is greater/equal than lower limit => $\varphi$ range between the limits, not including the $\varphi$ bin with value = 0 (HW index).
\end{itemize}

The values of $\eta$ and $\varphi$ have to be inside of only one of the two required ranges ("or").

Charge valid and charge sign bits must be equal to the requested charge.\\
The comparison of quality is done with LUT. To ignore quality comparison, all bits in the LUT have to be '1'.\\

\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|l|c|}\hline
LUT content (16 bits) & quality bits [22..19] & trigger \\\hline\hline
X"0000" & xxxx & no trigger\\\hline
X"0001" & 0000 & trigger on quality "level 0"\\\hline
X"0002" & 0001 & trigger on quality "level 1"\\\hline
X"0003" & 0001 or 0000 & trigger on quality "level 1" or "level 0"\\\hline
X"0004" & 0010 & trigger on quality "level 2"\\\hline
... & ...& ...\\\hline
X"8000" & 1111 & trigger on quality "level 15"\\\hline
X"C000" & 1111 or 1110 & trigger on quality "level 15" or "level 14"\\\hline
... & ...& ...\\\hline
X"FFFF" & xx & trigger on all quality "levels" (= "ignore")\\\hline
\end{tabular}
\end{center}
\caption{LUT contents for quality comparison of muon objects}
\label{tab:gtl:muon_lut_qual}
\end{table}

The comparison of isolation is done with LUT. To ignore isolation comparison, all bits in the LUT have to be '1' (see Table~\ref{tab:gtl:muon_lut_iso}).\\

\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|p{.4\columnwidth}|}\hline
LUT content (4 bits) & isolation bits [33..32] & trigger \\\hline\hline
X"0" & xx & no trigger\\\hline
X"1" & 00 & trigger on isolation bits = 00\\\hline
X"2" & 01 & trigger on isolation bits = 01\\\hline
X"3" & 00 or 01 & trigger on isolation bits = 00 or 01\\\hline
X"4" & 10 & trigger on isolation bits = 10\\\hline
X"5" & 00 or 10 & trigger on isolation bits = 00 or 10\\\hline
X"6" & 01 or 10 & trigger on isolation bits = 01 or 10\\\hline
X"7" & 00 or 01 or 10 & trigger on isolation bits = 00 or 01 or 10\\\hline
X"8" & 11 & trigger on isolation bits = 11\\\hline
X"9" & 00 or 11 & trigger on isolation bits = 00 or 11\\\hline
X"A" & 01 or 11 & trigger on isolation bits = 01 or 11\\\hline
X"B" & 00 or 01 or 11 & trigger on isolation bits = 00 or 01 or 11\\\hline
X"C" & 10 or 11 & trigger on isolation bits = 10 or 11\\\hline
X"D" & 00 or 10 or 11 & trigger on isolation bits = 00 or 10 or 11\\\hline
X"E" & 01 or 10 or 11 & trigger on isolation bits = 01 or 10 or 11\\\hline
X"F" & 00 or 01 or 10 or 11 & trigger on isolation bits = 00 or 01 or 10 or 11 (= "ignore" isolation)\\\hline
\end{tabular}
\end{center}
\caption{LUT contents for isolation comparison of muon objects}
\label{tab:gtl:muon_lut_iso}
\end{table}

\clearpage

\subsubsection{Correlation conditions}
\label{sec:gtl:correlation_conditions}

The correlation conditions contain a combination of two "Single object requirement conditions" of two object types or one "Double objects requirement condition" of objects of the same type. In addition with "object requirements" there are cuts for $\Delta\eta$, $\Delta\varphi$, $\Delta$R, mass and "two-body pt".\\

The following cuts can be used:
\begin{itemize}
\item Cut for $\Delta\eta$ (DETA).
\item Cut for $\Delta\varphi$ (DPHI).
\item Cut for $\Delta$R (DR).
\item Cuts for mass (MASS) of following mass types:
  \begin{itemize}
  \item Cut for Invariant mass.
  \item Cut for Invariant mass with unconstrained pt (only for muons).
  \item Cut for Invariant mass divided by $\Delta$R.
  \item Cut for Transverse mass.
  \end{itemize}
\item Cut for Two-body pt.
\end{itemize}

There is one correlation condition type for a mass cut with three objects:
\begin{itemize}
\item Cut for invariant mass for three objects (MASS).
\end{itemize}

\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{figures/scheme_vhdl_cuts_correllation_condition}
\caption{VHDL structure of cuts for correlation conditions} 
\label{fig:gtl:scheme_vhdl_cuts_correllation_condition}
\end{figure}

\paragraph{Correlation condition types}
\label{sec:gtl:correlation_condition_types}

As described in section Correlation conditions (\ref{sec:gtl:correlation_conditions}), correlations of two object types are available. Following possible correlations (objects 1-objects 2) are available, all implementated with \texttt{correlation\_conditions.vhd}:
\begin{itemize}
\item Correlation condition with calorimeter objects\\:
\egamma-\egamma, \egamma-jet, \egamma-tau, jet-jet, jet-tau and tau-tau are possible.)
\item Correlation condition for mass divided by $\Delta$R with calorimeter objects\\(:
\egamma-\egamma, \egamma-jet, \egamma-tau, jet-jet, jet-tau and tau-tau are possible.)
item Correlation condition with calorimeter objects and muons objects\\: \egamma-muon, jet-muon and tau-muon are possible.)
\item Correlation condition with muon objects\\
\item Correlation condition with calorimeter objects and \esums (\etm, ET$_{miss}^{HF}$ and \htm only)\\: \egamma-etm, jet-etm, tau-etm, \egamma-htm, jet-htm, tau-htm, \egamma-etmhf, jet-etmhf and tau-etmhf are possible.)
\item Correlation condition with muon objects\\
\item Correlation condition for mass divided by $\Delta$R with muon objects\\
\item Correlation condition with muon objects and \esums (\etm, ET$_{miss}^{HF}$ and \htm only)\\: muon-etm, muon-etmhf and muon-htm are possible.)
\end{itemize}

There is one modules for calorimeter objects correlation condition with calorimeter object overlap removal:
\begin{itemize}
\item Correlation condition for calorimeter objects with calorimeter object overlap removal\\(\texttt{calo\_calo\_calo\_correlation\_orm\_condition.vhd}
\end{itemize}

There are two modules for mass with three objects:
\begin{itemize}
\item Correlation condition for mass with three objects with calorimeter objects (same type, same bunch-crossing)\\(\texttt{calo\_calo\_mass\_3\_obj\_condition.vhd}
\item Correlation condition for mass with three objects with muon objects\\(\texttt{muon\_muon\_mass\_3\_obj\_condition.vhd})
\end{itemize}

\subparagraph{Overview of possible correlation cuts in conditions}
\label{sec:gtl:overview_correlation_cuts}

The following list gives an overview of possible correlation cuts in conditions:

\begin{itemize}
\item Calo conditions (calo\_conditions.vhd):
    \begin{itemize}
    \item two-body pt (for double condition)
    \end{itemize}
\item Calo conditions overlap removal (calo\_conditions\_orm.vhd):
    \begin{itemize}
    \item $\Delta\eta$ overlap removal
    \item $\Delta\varphi$ overlap removal
    \item $\Delta$R overlap removal
    \item two-body pt (for double condition)
    \end{itemize}
\item Muon conditions (muon\_conditions.vhd):
    \begin{itemize}
    \item charge correlation
    \item two-body pt (for double condition)
    \end{itemize}
% % HB 2020-09-11: MJ checks whether it makes sense!
% Muon conditions overlap removal (muon\_conditions\_orm.vhd):
% \begin{itemize}
% \item charge correlation
% \item $\Delta\eta$ overlap removal
% \item $\Delta\varphi$ overlap removal
% \item $\Delta$R overlap removal
% \item two-body pt (for double condition)
% \end{itemize} 
\item Calo calo correlation condition with calo overlap removal (calo\_calo\_calo\_correlation\_orm\_condition.vhd):
    \begin{itemize}
    \item $\Delta\eta$ overlap removal
    \item $\Delta\varphi$ overlap removal
    \item $\Delta$R overlap removal
    \item $\Delta\eta$
    \item $\Delta\varphi$
    \item $\Delta$R
    \item invariant mass
    \item two-body pt
    \end{itemize} 
\item Calo calo correlation condition (correlation\_conditions.vhd):
    \begin{itemize}
    \item $\Delta\eta$
    \item $\Delta\varphi$
    \item $\Delta$R
    \item invariant mass
    \item two-body pt
    \end{itemize}
\item Calo calo correlation condition for invariant mass divided by $\Delta$R (correlation\_conditions.vhd):
    \begin{itemize}
    \item invariant mass divided by $\Delta$R
    \end{itemize}
\item Calo calo correlation condition mass with three objects (calo\_calo\_mass\_3\_obj\_condition.vhd):
    \begin{itemize}
    \item invariant mass with three objects
    \end{itemize} 
\item Calo muon correlation condition (correlation\_conditions.vhd):
    \begin{itemize}
    \item $\Delta\eta$
    \item $\Delta\varphi$
    \item $\Delta$R
    \item invariant mass
    \item two-body pt
    \end{itemize} 
\item Calo esums correlation condition (correlation\_conditions.vhd):
    \begin{itemize}
    \item $\Delta\varphi$
    \item transverse mass
    \item two-body pt
    \end{itemize}
\item Muon muon correlation condition (correlation\_conditions.vhd):
    \begin{itemize}
    \item charge correlation
    \item $\Delta\eta$
    \item $\Delta\varphi$
    \item $\Delta$R
    \item invariant mass or invariant mass unconstraint pt
    \item two-body pt
    \end{itemize}
\item Muon muon correlation condition for invariant mass divided by $\Delta$R (correlation\_conditions.vhd):
    \begin{itemize}
    \item charge correlation
    \item invariant mass divided by $\Delta$R
    \end{itemize}
\item Muon muon correlation condition mass with three objects (muon\_muon\_mass\_3\_obj\_condition.vhd):
    \begin{itemize}
    \item charge correlation
    \item invariant mass with three objects
    \end{itemize} 
\item Muon esums correlation condition (correlation\_conditions.vhd):
    \begin{itemize}
    \item $\Delta\varphi$
    \item transverse mass
    \item two-body pt
    \end{itemize}
\end{itemize}

\subparagraph{Correlation condition types}
\label{sec:gtl:correlation_condition_types}

The VHDL module \texttt{correlation\_conditions.vhd} is instantiated for all correlation conditions with two objects.
The correlation conditions module contains two "Single object requirement conditions" for different object types or same type with data from different bunch-crossings as one possible mode and a "Double objects requirement condition" objects of same type and same bunch-crossing as a second mode (selection is done by a parameter in the generic list of \texttt{correlation\_conditions.vhd} named "same\_bx").\\
In addition there are "Cuts" for differences in $\eta$ (DETA) and $\varphi$ (DPHI), a calculation of $\Delta$R (DR), a calculation of invariant mass (MASS) or invariant mass with unconstrained pt (MASS) or invariant mass divided by $\Delta$R (MASS) or transverse mass (MASS) and a calculation of two-body pt, see Figure~\ref{fig:gtl:scheme_vhdl_cuts_correllation_condition}.\\
The calculation of all these cuts is done outdside of correlation conditions for all needed object type bunch-crossing combinations. Results of these calculations are inputs to the instantiated correlation conditions module depending which cuts are used in a certain condition. The comparison with limits or thresholds is part of this module.

For the VHDL entity declaration of correlation conditions module in \texttt{correlation\_conditions.vhd}, see Listing~\ref{lst:correlation_conditions_vhd}.\\
\clearpage
%% "automatic generation" of listings (see /scripts/extract_entities.sh)
\lstinputlisting[label=lst:correlation_conditions_vhd,language=VHDL,caption=Entity declaration of \texttt{correlation\_conditions.vhd}]{interfaces/correlation_conditions.vhd}

\clearpage

\begin{longtable}{>{\footnotesize}l >{\footnotesize}p{.65\columnwidth}}
\caption{Explanation of Listing~\ref{lst:correlation_conditions_vhd}}\\
\hline 
{Item} & {Explanation}\\
\hline 
\endhead
\verb|same_bx| & boolean indicating whether data are from same Bx - 'true' for same Bx.\\
\verb|nr_obj1| & number of objects (valid numbers: 0..11).\\
\verb|type_obj1| & type of objects (valid stings: EG\_TYPE, ...).\\
\verb|slice_low_obj1| & low index of object range (valid numbers: 0..11).\\
\verb|slice_high_obj1| & high index of object range (valid numbers: 0..11, but greater or equal slice\_low\_obj1.\\
\verb|pt_ge_mode_obj1| & 'mode-selection' for the \et comparator. Valid strings are 'true' and 'false' (type is boolean), 'true' means comparator works on greater/equal, 'false' means equal (for tests only).\\
\verb|pt_threshold_obj1| & threshold value for comparison in \pt.\\
\verb|nr_eta_windows_obj1| & integer value for number of $\eta$ cuts.\\
\verb|eta_w1_upper_limit_obj1| & "upper limit" of "window"-comparator 1 for $\eta$.\\
\verb|eta_w1_lower_limit_obj1| & "lower limit" of "window"-comparator 1 for $\eta$.\\
\verb|eta_w2_upper_limit_obj1| & "upper limit" of "window"-comparator 2 for $\eta$.\\
\verb|eta_w2_lower_limit_obj1| & "lower limit" of "window"-comparator 2 for $\eta$.\\
\verb|eta_w3_upper_limit_obj1| & "upper limit" of "window"-comparator 3 for $\eta$.\\
\verb|eta_w3_lower_limit_obj1| & "lower limit" of "window"-comparator 3 for $\eta$.\\
\verb|eta_w4_upper_limit_obj1| & "upper limit" of "window"-comparator 4 for $\eta$.\\
\verb|eta_w4_lower_limit_obj1| & "lower limit" of "window"-comparator 4 for $\eta$.\\
\verb|eta_w5_upper_limit_obj1| & "upper limit" of "window"-comparator 5 for $\eta$.\\
\verb|eta_w5_lower_limit_obj1| & "lower limit" of "window"-comparator 5 for $\eta$.\\
\verb|phi_full_range_obj1| & boolean to set full range of $\varphi$.\\
\verb|phi_w1_upper_limit_obj1| & "upper limit" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w1_lower_limit_obj1| & "lower limit" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w2_ignore_obj1| & boolean to ignore "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_upper_limit_obj1| & "upper limit" of "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_lower_limit_obj1| & "lower limit" of "window"-comparator 2 for $\varphi$.\\
\verb|calo_iso_lut_obj1| & content of LUT (4 bits) for calo isolation comparison.\\
\verb|muon_requested_charge_obj1| & requested charge in string (valid stings: "ign", "pos" or "neg").\\
\verb|muon_qual_lut_obj1| & content of LUT (16 bits) for quality comparison.\\
\verb|muon_iso_lut_obj1| & content of LUT (4 bits) for muon isolation comparison.\\
\verb|muon_upt_cut_obj1| & boolean to select cut for unconstrained \pt.\\
\verb|muon_upt_upper_limit_obj1| & "upper limit" for comparison in unconstrained \pt.\\
\verb|muon_upt_lower_limit_obj1| & "lower limit" for comparison in unconstrained \pt.\\
\verb|muon_ip_lut_obj1| & content of LUT (4 bits) for impact parameter comparison.\\
\verb|nr_obj2| & number of objects (valid numbers: 0..11).\\
\verb|type_obj2| & type of objects (valid stings: EG\_TYPE, ...).\\
\verb|slice_low_obj2| & low index of object range (valid numbers: 0..11).\\
\verb|slice_high_obj2| & high index of object range (valid numbers: 0..11, but greater or equal slice\_low\_obj1.\\
\verb|pt_ge_mode_obj2| & 'mode-selection' for the \et comparator. Valid strings are 'true' and 'false' (type is boolean), 'true' means comparator works on greater/equal, 'false' means equal (for tests only).\\
\verb|pt_threshold_obj2| & threshold value for comparison in \pt.\\
\verb|nr_eta_windows_obj2| & integer value for number of $\eta$ cuts.\\
\verb|eta_w1_upper_limit_obj2| & "upper limit" of "window"-comparator 1 for $\eta$.\\
\verb|eta_w1_lower_limit_obj2| & "lower limit" of "window"-comparator 1 for $\eta$.\\
\verb|eta_w2_upper_limit_obj2| & "upper limit" of "window"-comparator 2 for $\eta$.\\
\verb|eta_w2_lower_limit_obj2| & "lower limit" of "window"-comparator 2 for $\eta$.\\
\verb|eta_w3_upper_limit_obj2| & "upper limit" of "window"-comparator 3 for $\eta$.\\
\verb|eta_w3_lower_limit_obj2| & "lower limit" of "window"-comparator 3 for $\eta$.\\
\verb|eta_w4_upper_limit_obj2| & "upper limit" of "window"-comparator 4 for $\eta$.\\
\verb|eta_w4_lower_limit_obj2| & "lower limit" of "window"-comparator 4 for $\eta$.\\
\verb|eta_w5_upper_limit_obj2| & "upper limit" of "window"-comparator 5 for $\eta$.\\
\verb|eta_w5_lower_limit_obj2| & "lower limit" of "window"-comparator 5 for $\eta$.\\
\verb|phi_full_range_obj2| & boolean to set full range of $\varphi$.\\
\verb|phi_w1_upper_limit_obj2| & "upper limit" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w1_lower_limit_obj2| & "lower limit" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w2_ignore_obj2| & boolean to ignore "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_upper_limit_obj2| & "upper limit" of "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_lower_limit_obj2| & "lower limits" of "window"-comparator 2 for $\varphi$.\\
\verb|calo_iso_lut_obj2| & content of LUT (4 bits) for isolation comparison.\\
\verb|muon_requested_charge_obj2| & requested charge in string (valid stings: "ign", "pos" or "neg").\\
\verb|muon_qual_lut_obj2| & content of LUT (16 bits) for quality comparison.\\
\verb|muon_iso_lut_obj2| & content of LUT (4 bits) for muon isolation comparison.\\
\verb|muon_upt_cut_obj2| & boolean to select cut for unconstrained \pt.\\
\verb|muon_upt_upper_limit_obj2| & "upper limit" for comparison in unconstrained \pt.\\
\verb|muon_upt_lower_limit_obj2| & "lower limit" for comparison in unconstrained \pt.\\
\verb|muon_ip_lut_obj2| & content of LUT (4 bits) for impact parameter comparison.\\
\verb|sel_esums| & boolean to select correlation with esums object.\\
\verb|nr_esums| & number of objects (valid number: 1).\\
\verb|obj_type_esums| & type of objects (valid stings: ETM\_TYPE, ...).\\
\verb|et_ge_mode_esums| & 'mode-selection' for the \et comparator. Valid strings are 'true' and 'false' (type is boolean), 'true' means comparator works on greater/equal, 'false' means equal (for tests only).\\
\verb|et_threshold_esums| & threshold value for comparison in \pt.\\
\verb|phi_full_range_esums| & boolean to set full range of $\varphi$.\\
\verb|phi_w1_upper_limit_esums| & "upper limit" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w1_lower_limit_esums| & "lower limit" of "window"-comparator 1 for $\varphi$.\\
\verb|phi_w2_ignore_esums| & boolean to ignore "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_upper_limit_esums| & "upper limit" of "window"-comparator 2 for $\varphi$.\\
\verb|phi_w2_lower_limit_esums| & "lower limits" of "window"-comparator 2 for $\varphi$.\\
\verb|muon_requested_charge_correlation| & requested charge correlation in string (valid stings: "ig", "ls" or "os").\\
\verb|deta_cut| & boolean to select use of differences in $\eta$ cut.\\
\verb|deta_upper_limit| & "upper limit" of "window"-comparator for comparison of differences in $\eta$ (hex value).\\
\verb|deta_lower_limit| & "lower limit" of "window"-comparator for comparison of differences in $\eta$ (hex value).\\
\verb|dphi_cut| & boolean to select use of differences in $\varphi$ cut.\\
\verb|dphi_upper_limit| & "upper limit" of "window"-comparator for comparison of differences in $\varphi$ (hex value).\\
\verb|dphi_lower_limit| & "lower limit" of "window"-comparator for comparison of differences in $\varphi$ (hex value).\\
\verb|dr_cut| & boolean to select use of $\Delta$R cut.\\
\verb|dr_upper_limit| & "upper limit" of "window"-comparator for comparison of $\Delta$$R^2$ (hex value).\\
\verb|dr_lower_limit| & "lower limit" of "window"-comparator for comparison of $\Delta$$R^2$ (hex value).\\
\verb|mass_cut| & boolean to select use of mass cut.\\
\verb|mass_type| & selection of mass cut type (e.g. INVARIANT\_MASS\_TYPE).\\
\verb|mass_width| & definition of mass cut vector width.\\
\verb|mass_upper_limit| & "upper limit" of "window"-comparator for comparison of $\frac{M^2}{2}$ (hex value).\\
\verb|mass_lower_limit| & "lower limit" of "window"-comparator for comparison of $\frac{M^2}{2}$ (hex value).\\
\verb|mass_div_dr_width| & definition of mass divided by $\Delta$R cut vector width.\\
\verb|mass_div_dr_threshold| & threshold for comparison of $\frac{M^2}{2}\times$(1/$\Delta$$R^2$) (hex value).\\
\verb|twobody_pt_cut| & boolean to select use of two-body pt cut.\\
\verb|tbpt_width| & definition of two-body pt cut vector width.\\
\verb|tbpt_threshold| & threshold for comparison of two-body pt (hex value).\\
\verb|lhc_clk| & clock input (LHC clock).\\
\verb|calo1_data_i| & calorimeter input data, structure defined with \texttt{type\_obj1}.\\
\verb|calo2_data_i| & calorimeter input data, structure defined with \texttt{type\_obj2}.\\
\verb|esums_data_i| & esums input data, structure defined with \texttt{obj\_type\_esums}.\\
\verb|muon1_data_i| & calorimeter input data, structure defined with \texttt{type\_obj1}.\\
\verb|muon2_data_i| & calorimeter input data, structure defined with \texttt{type\_obj2}.\\
\verb|ls_charcorr_double| & muon charge correlation input data for "like sign".\\
\verb|os_charcorr_double| & muon charge correlation input data for "opposite sign".\\
\verb|deta| & differences in $\eta$ input data.\\
\verb|dphi| & differences in $\varphi$ input data.\\
\verb|dr| & $\Delta$R input data.\\
\verb|mass_inv| & invariant mass input data.\\
\verb|mass_inv_upt| & invariant mass with unconstrained \pt input data.\\
\verb|mass_trv| & transverse mass input data.\\
\verb|mass_div_dr| & invariant mass divided by $\Delta$R input data.\\
\verb|tbpt| & two-body pt input data.\\
\verb|condition_o| & output of condition (routed to Algorithms logic, see \ref{sec:gtl:algorithms_logic}).\\
\hline 
\label{tab:gtl:explanation_correlation_conditions_vhd}
\end{longtable}

% \subparagraph{Calo Calo Correlation condition module - template for VHDL-Producer}
% See in Chapter \ref{sec:gtl:templates_tme} and in Listing~\ref{lst:instance_calo_calo_correlation_condition_vhd} for a VHDL-template for VHDL-Producer of
% instantiating a calorimeter-calorimeter-correlation condition (\texttt{calo\_calo\_correlation\_condition.vhd}).\\

\subparagraph{Calo Calo Correlation condition module with Calo Overlap Remover}
\label{sec:gtl:calo_calo_overlap_remover_condition_module}

The Calo Calo Overlap Remover Correlation conditions consits of two modes. One with a Calo Calo Correlation condition with "Double objects requirement condition" for calo objects of same type and same bunch-crossing (\ref{sec:gtl:calo_calo_correlation_condition_module}) and a single condition for a different calo object type (can have different bunch-crossing too). There has to be at least one correlation cut for the objects of "Double objects requirement condition" and a correlation cut for overlap removal between objects (one or more cut(s) of $\Delta\eta$, $\Delta\varphi$ and $\Delta$R) of different object types ("2plus1"). A second mode ("1plus1") with a Calo Calo Correlation condition with a single condition and a different calo object type (can have different bunch-crossing too) also with a single condition. There has to be at least one correlation cut for the different objects (e.g. invariant mass) and a correlation cut for overlap removal between the objects (one or more cut(s) of $\Delta\eta$, $\Delta\varphi$ and $\Delta$R).\\
Overlap Remover Correlation conditions \texttt{calo\_calo\_calo\_correlation\_orm\_condition.vhd} are implemented only for calo object types.

\subparagraph{Calo Calo Correlation condition module for Invariant Mass with Three Objects}
\label{sec:gtl:calo_correlation_condition_module_mass_3_obj}

The calo correlation condition module for invariant mass with three objects (\texttt{calo\_calo\_mass\_3\_obj\_condition.vhd)} contains a "Triple objects requirement condition" for calo objects of same type and same bunch-crossing.\\
In addition a "Cut" for calculation of \textit{invariant mass with three objects} (see \ref{sec:gtl:inv_mass_3_obj_calculation}) is mandatory.\\
No other correlation cuts available in this condition type.

\subparagraph{Muon Muon Correlation condition module for Invariant Mass with Three Objects}
\label{sec:gtl:muon_correlation_condition_module_mass_3_obj}

The muon correlation condition module for invariant mass with three objects (\texttt{muon\_muon\_mass\_3\_obj\_condition.vhd)} contains a "Triple objects requirement condition" for objects of same type and same bunch-crossing.\\
In addition a "Cut" for calculation of \textit{invariant mass with three objects} (see \ref{sec:gtl:inv_mass_3_obj_calculation}) is mandatory.\\
No other correlation cuts, except "charge correlation", available in this condition type.

% \subparagraph{Calo Muon Muon B-tagging condition module}
% \label{sec:gtl:calo_muon_muon_b_tagging_condition_module}
% 
% \textbf{Insert new text !!!}

\subsubsection{External Conditions}
\label{sec:gtl:external_conditions}
Maximal 256 External Conditions are possible in \gt. They are provided as inputs in the Algorithms logic of \ugtl.
External Conditions will include the "Technical Trigger" of the legacy system.

\subsubsection{Algorithms logic}
\label{sec:gtl:algorithms_logic}

The outputs of all the instantiated conditions are combined in the Algorithms logic with boolean algebra given by TME for every single Algorithm. These Algorithms are registered and provided
as inputs for \fdl.

\clearpage

\subsection{VHDL-Templates for VHDL-Producer}
\label{sec:gtl:templates_tme}

The VHDL-Producer software generates a set of VHDL files (\texttt{gtl\_module\_instances.vhd, gtl\_module\_signals.vhd, ugt\_constants.vhd and algo\_index.vhd}) which contain the requirements
of a certain L1Menu, set in the TME. The templates are created in "Jinja2" (a template engine for python).
All the templates described in this section, are located in:\\\texttt{../cactusprojects/utm/tmVhdlProducer/templates/vhdl}.

\textbf{Insert new text !!!}

% \subsubsection{Global Trigger Logic module - template for VHDL-Producer}
% In the Trigger Menu Editor one can generate a set of conditions, which are instantiated in the top-of-hierarchy module (\texttt{gtl\_module.vhd}). This is done by reading a
% VHDL-template of a condition module and replacing substitution parameters with values given to VHDL Producer.\\
% % In the template of Global Trigger Logic module (\texttt{gtl\_module\_instances.vhd}), the inserting of signal declarations and instances is specified by Jinja2 substitution parameters.
% 
% \paragraph{Signal declarations}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/signal\_correlation\_conditions\_pt\_eta\_phi.vhd.j2"\%}} => replace with string defined in template:\\
% \texttt{signal\_correlation\_conditions\_pt\_eta\_phi.vhd.j2}.\\
% Insert template as often as an ObjectType at a certain Bx is used in a correlation condition.
%     \begin{itemize}
%     \item Parameters in template\\ \texttt{signal\_correlation\_conditions\_pt\_eta\_phi.vhd.j2}:\\
%     \textit{\{\{objName\}\}} => ObjectType used in a correlation condition.\\ 
%     \textit{\{\{Bx\}\}} => bunch-crossing within $\pm$2 of ObjectType used in a correlation condition.\\
%     \end{itemize}
% \end{itemize}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/signal\_correlation\_conditions\_differences.vhd.j2"\%}} => replace with string defined in template:\\
% \texttt{signal\_correlation\_conditions\_differences.vhd.j2}.\\
% Insert template once for correlation conditions of different ObjectTypes and Bx combinations.    
% \begin{itemize}
%     \item Parameters in template\\ \texttt{signal\_correlation\_conditions\_differences.vhd.j2}:\\
%     \textit{\{\{objName1\}\}} => ObjectType of objects 1 used in a correlation condition.\\ 
%     \textit{\{\{objName2\}\}} => ObjectType of objects 2 used in a correlation condition.\\ 
%     \textit{\{\{Bx1\}\}} => bunch-crossing within $\pm$2 of objects 1.\\
%     \textit{\{\{Bx2\}\}} => bunch-crossing within $\pm$2 of objects 2.\\
%     \end{itemize}
% \end{itemize}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/signal\_muon\_charge\_correlations.ja.vhd"\%}} => replace with string defined in template:\\
% \texttt{signal\_muon\_charge\_correlations.vhd} for at least one occurance of a DoubleMuon, TripleMuon or QuadMuon condition in a certain bunch-crossing.
%     \begin{itemize}
%     \item Parameters in template\\ \texttt{signal\_muon\_charge\_correlations.vhd}:\\
%     \textit{\{\{Bx\}\}} => bunch-crossing within $\pm$2.
%     \end{itemize}
% \end{itemize}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/signal\_condition.ja.vhd"\%}} => replace with string defined in template:\\
% \texttt{signal\_condition.ja.vhd} as often as conditions are used.
%     \begin{itemize}
%     \item Parameters in template\\ \texttt{signal\_condition.ja.vhd}:\\
%     \textit{\{\{ConditionName\}\}} => unique condition name given by physicist to TME.
%     \end{itemize}
% \end{itemize}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/signal\_algorithm.ja.vhd"\%}} => replace with string defined in template:\\
% \texttt{signal\_algorithm.ja.vhd} as often as algorithms are used.
%     \begin{itemize}
%     \item Parameters in template\\ \texttt{signal\_algorithm.ja.vhd}:\\
%     \textit{\{\{AlgoName\}\}} => unique algorithm name given by physicist to TME.
%     \end{itemize}
% \end{itemize}
% 
% \paragraph{Instances}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/instance\_correlation\_conditions\_pt\_eta\_phi.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_correlation\_conditions\_pt\_eta\_phi.vhd.j2}.\\
% Instantiations of loops for pt, eta and phi signals for correlation conditions (used for DETA, DPHI and DR) - once for every ObjectType in certain Bx used in correlation conditions.
%     \begin{itemize}
%     \item Parameters in template\\ \texttt{instance\_correlation\_conditions\_pt\_eta\_phi.vhd.j2}:\\
%     \textit{\{\{objName\}\}} => ObjectType used in a correlation condition.\\ 
%     \textit{\{\{Bx\}\}} => bunch-crossing within $\pm$2 of ObjectType used in a correlation condition.\\
%     \end{itemize}
% \end{itemize}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/instance\_correlation\_conditions\_eta\_phi\_conversion.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_correlation\_conditions\_eta\_phi\_conversion.vhd.j2}.\\
% Instantiations of loops for eta and phi converted signals (to muon scale) for calo-muon correlation conditions - once for every calo ObjectType in certain Bx used in calo-muon correlation conditions
%     \begin{itemize}
%     \item Parameters in template\\ \texttt{instance\_correlation\_conditions\_eta\_phi\_conversion.vhd.j2}:\\
%     \textit{\{\{objName\}\}} => ObjectType used in a correlation condition.\\ 
%     \textit{\{\{Bx\}\}} => bunch-crossing within $\pm$2 of ObjectType used in a correlation condition.\\
%     \end{itemize}
% \end{itemize}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/subTemplates/instance\_correlation\_conditions\_differences.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_correlation\_conditions\_differences.vhd.j2}.\\ 
% Instantiations of differences for correlation conditions (used for DETA, DPHI and DR) - once for correlation conditions with two ObjectTypes in certain Bxs
%     \begin{itemize}
%     \item Parameters in template\\ \texttt{instance\_correlation\_conditions\_differences.vhd.j2}:\\
%     \textit{\{\{objName1\}\}} => ObjectType of object 1 of correlation condition.\\ 
%     \textit{\{\{objName2\}\}} => ObjectType of object 2 of correlation condition.\\ 
%     \textit{\{\{Bx1\}\}} => bunch-crossing within $\pm$2 of object 1.\\
%     \textit{\{\{Bx2\}\}} => bunch-crossing within $\pm$2 of object 2.
%     \end{itemize}
% \end{itemize}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/instance\_correlation\_conditions\_inv\_mass.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_correlation\_conditions\_inv\_mass.vhd.j2}.\\ 
% Instantiations of cosh-deta and cos-dphi LUTs for correlation conditions (used for invariant mass) - once for correlation conditions with two ObjectTypes in certain Bxs
%     \begin{itemize}
%     \item Parameters in template\\ \texttt{instance\_correlation\_conditions\_inv\_mass.vhd.j2}:\\
%     \textit{\{\{objName1\}\}} => ObjectType of object 1 of correlation condition.\\ 
%     \textit{\{\{objName2\}\}} => ObjectType of object 2 of correlation condition.\\ 
%     \textit{\{\{Bx1\}\}} => bunch-crossing within $\pm$2 of object 1.\\
%     \textit{\{\{Bx2\}\}} => bunch-crossing within $\pm$2 of object 2.
%     \end{itemize}
% \end{itemize}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/instance\_muon\_charge\_correlation.ja.vhd"\%}} => replace with string defined in template:\\
% \texttt{instance\_muon\_charge\_correlations.ja.vhd} only once in a certain Bx,
% if there is at least one DoubleMuon, TripleMuon or QuadMuon condition. Instantiations of muon charge correlations.
%     \begin{itemize}
%     \item Parameters in template\\ \texttt{instance\_muon\_charge\_correlations.vhd}:\\
%     \textit{\{\{Bx\}\}} => bunch-crossing within $\pm$2.
%     \end{itemize}
% \end{itemize}
% \begin{itemize}
% \item \textit{{\%- include "subTemplates/instance\_calo\_condition.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_calo\_condition.vhd.j2}.\\
% \item \textit{{\%- include "subTemplates/instance\_muon\_condition.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_muon\_condition.vhd.j2}.\\
% \item \textit{{\%- include "subTemplates/instance\_esums\_condition.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_esums\_condition.vhd.j2}.\\
% \item \textit{{\%- include "subTemplates/instance\_calo\_calo\_correlation\_condition.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_calo\_calo\_correlation\_condition.vhd.j2}.\\
% \item \textit{{\%- include "subTemplates/instance\_calo\_muon\_correlation\_condition.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_calo\_muon\_correlation\_condition.vhd.j2}.\\
% \item \textit{{\%- include "subTemplates/instance\_muon\_muon\_correlation\_condition.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_muon\_muon\_correlation\_condition.vhd.j2}.\\
% \item \textit{{\%- include "subTemplates/instance\_algorithm.vhd.j2"\%}} => replace with strings defined in template:\\
% \texttt{instance\_algorithm.vhd.j2}.\\
% \end{itemize}
% 
% Additionally there are lines with comments which VHDL-Producer should replace as described in \ref{sec:gtl:gtl_pkg_template_tme}.
% 
% \subsubsection{Algorithms mapping module - template for VHDL-Producer}
% \label{sec:gtl:algo_mapping_tme}
% The template of Algorithms mapping module (\texttt{subTemplates/algo\_mapping\_rop.vhd}) is used to create the VHDL-file \texttt{algo\_mapping\_rop.vhd}.
% 
\subsubsection{Calorimeter conditions - template for VHDL-Producer}\label{sec:gtl:calo_conditions_tme}
A VHDL-template for VHDL-Producer of instantiating\\ \texttt{calo\_conditions.vhd} is given below (see Listing~\ref{lst:instance_calo_condition_vhd}).\\

%% "automatic generation" of listings (see /scripts/extract_entities.sh)
\lstinputlisting[label=lst:instance_calo_condition_vhd,language=VHDL,caption=Template of \texttt{calo\_conditions.vhd} for VHDL-Producer]{interfaces/instance_calo_condition.vhd.j2}

\medskip
\begin{table}[htdp]
\footnotesize
\begin{center}
\begin{tabular}{l p{.65\columnwidth}}
\toprule
{Item} & {Explanation}\\
\midrule       
\verb|vhdl_signal| & condition name.\\
\verb|sliceLow| & low value of an object slice.\\
\verb|sliceHigh| & high value of an object slice.\\
\verb|nr_objects| & valid values are 1 (for single), 2 (double), 3 (triple) and 4 (quad) - depending on condition type.\\
\verb|operator| & valid strings are 'true' and 'false' - 'true' for greater/equal-, 'false' for equal-mode of \et comparator.\\
\verb|type| & valid strings are 'EG', 'JET', and 'TAU'.\\
\verb|threshold| & array with requirements for et\_thresholds (4x 16-bit values, hex notation). Valid values depending on the scales of \et.\\
\verb|nrEtaWindows| & array to set number of $\eta$ cuts.\\
\verb|etaW1UpperLimit, ...| & arrays of limits for "window"-comparators for $\eta$ (4x 16-bit values, hex notation). Valid values depending on the scales for $\eta$.\\
\verb|phiFullRange| & array to set full range of $\varphi$ (4x boolean).\\
\verb|phiW1UpperLimit, ...| & arrays of limits for "window"-comparators for $\varphi$ (4x 16-bit values, hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|[phiW2Ignore| & array to ignore "window"-comparator 2 of $\varphi$ (4x boolean).\\
\verb|isolationLUT| & array for LUTs (4 bits) of isolation).\\
\verb|twoBodyPt.threshold| & value of threshold for two-body pt comparison.\\
\verb|bx| & valid strings are 'p2', 'p1', '0', 'm1' and 'm2'. This indicates which data in a range of plus/minus 2 bunch-crossing is used in the condition.\\
\bottomrule
\end{tabular}
\end{center}
\caption{Explanation of Listing~\ref{lst:instance_calo_condition_vhd}}
\label{tab:gtl:explanation_instance_calo_condition_vhd}
\end{table}

\clearpage

\subsubsection{Energy sum quantities conditions - template for VHDL-Producer}
\label{sec:gtl:esums_conditions_tme}
A VHDL-template for VHDL-Producer of instantiating\\ \texttt{esums\_conditions.vhd}\\ is given below (see Listing~\ref{lst:instance_esums_condition_vhd}).\\

%% "automatic generation" of listings (see /scripts/extract_entities.sh)
\lstinputlisting[label=lst:instance_esums_condition_vhd,language=VHDL,caption=Template of \texttt{esums\_conditions.vhd} for VHDL-Producer]{interfaces/instance_esums_condition.vhd.j2}

\medskip
\begin{table}[htdp]
\footnotesize
\begin{center}
\begin{tabular}{l p{.65\columnwidth}}
\toprule
{Item} & {Explanation}\\
\midrule       
\verb|vhdl_signal| & condition name.\\
\verb|operator| & valid strings are 'true' and 'false' - 'true' for greater/equal-, 'false' for equal-mode of \et comparator.\\
\verb|type| & valid strings are 'EG', 'JET', and 'TAU'.\\
\verb|threshold| & array with requirements for et\_thresholds (4x 16-bit values, hex notation). Valid values depending on the scales of \et.\\
\verb|phiFullRange| & array to set full range of $\varphi$ (4x boolean).\\
\verb|phiW1UpperLimit, ...| & arrays of limits for "window"-comparators for $\varphi$ (4x 16-bit values, hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|phiW2Ignore| & array to ignore "window"-comparator 2 of $\varphi$ (4x boolean).\\
\verb|bx| & valid strings are 'p2', 'p1', '0', 'm1' and 'm2'. This indicates which data in a range of plus/minus 2 bunch-crossing is used in the condition.\\
\bottomrule
\end{tabular}
\end{center}
\caption{Explanation of Listing~\ref{lst:instance_esums_condition_vhd}}
\label{tab:gtl:explanation_instance_esums_condition_vhd}
\end{table}

\clearpage

\subsubsection{Muon conditions - template for VHDL-Producer}
A VHDL-template for VHDL-Producer of instantiating\\ \texttt{muon\_conditions.vhd}\\ is given below (see Listing~\ref{lst:instance_muon_condition_vhd}).\\

%% "automatic generation" of listings (see /scripts/extract_entities.sh)
\lstinputlisting[label=lst:instance_muon_condition_vhd,language=VHDL,caption=Template of \texttt{muon\_conditions.vhd} for VHDL-Producer]{interfaces/instance_muon_condition.vhd.j2}

\medskip
\begin{table}[htdp]
\footnotesize
\begin{center}
\begin{tabular}{l p{.65\columnwidth}}
\toprule
{Item} & {Explanation}\\
\midrule       
\verb|vhdl_signal| & condition name.\\
\verb|sliceLow| & low value of an object slice.\\
\verb|sliceHigh| & high value of an object slice.\\
\verb|nr_objects| & valid values are 1 (for single), 2 (double), 3 (triple) and 4 (quad) - depending on condition type.\\
\verb|operator| & valid strings are 'true' and 'false' - 'true' for greater/equal-, 'false' for equal-mode of \et comparator.\\
\verb|type| & valid strings are 'EG', 'JET', and 'TAU'.\\
\verb|threshold| & array with requirements for et\_thresholds (4x 16-bit values, hex notation). Valid values depending on the scales of \et.\\
\verb|nrEtaWindows| & array to set number of $\eta$ cuts.\\
\verb|etaW1UpperLimit, ...| & arrays of limits for "window"-comparators for $\eta$ (4x 16-bit values, hex notation). Valid values depending on the scales for $\eta$.\\
\verb|phiFullRange| & array to set full range of $\varphi$ (4x boolean).\\
\verb|phiW1UpperLimit, ...| & arrays of limits for "window"-comparators for $\varphi$ (4x 16-bit values, hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|[phiW2Ignore| & array to ignore "window"-comparator 2 of $\varphi$ (4x boolean).\\
\verb|charge| & array for requested charge (4x strings). Valid strings are 'pos' ("positive charge") and 'neg' ("negative charge") and 'ign' ("ignore").\\
\verb|qualityLUT| & array for LUTs (16 bits) of quality.\\
\verb|isolationLUT| & array for LUTs (4 bits) of isolation).\\
\verb|twoBodyPt.threshold| & value of threshold for two-body pt comparison.\\
\verb|bx| & valid strings are 'p2', 'p1', '0', 'm1' and 'm2'. This indicates which data in a range of plus/minus 2 bunch-crossing is used in the condition.\\
\bottomrule
\end{tabular}
\end{center}
\caption{Explanation of Listing~\ref{lst:instance_muon_condition_vhd}}
\label{tab:gtl:explanation_instance_muon_condition_vhd}
\end{table}

\clearpage

\subsubsection{Calo Calo Correlation condition - template for VHDL-Producer}
A VHDL-template for VHDL-Producer of instantiating\\ \texttt{calo\_calo\_correlation\_condition.vhd}\\ is given below (see Listing~\ref{lst:instance_calo_calo_correlation_condition_vhd}).\\

%% "automatic generation" of listings (see /scripts/extract_entities.sh)
\lstinputlisting[label=lst:instance_calo_calo_correlation_condition_vhd,language=VHDL,caption=Template of \texttt{calo\_calo\_correlation\_condition.vhd} for VHDL-Producer]{interfaces/instance_calo_calo_correlation_condition.vhd.j2}

\begin{longtable}{>{\footnotesize}l >{\footnotesize}p{.65\columnwidth}}
\caption{Explanation of Listing~\ref{lst:instance_calo_calo_correlation_condition_vhd}}\\
\hline 
{Item} & {Explanation}\\
\hline 
\endhead
\verb|vhdl_signal| & condition name.\\
\verb|objectsInSameBx| & valid strings are 'true' and 'false' - 'true' for data with same Bx.\\
\verb|deltaEta.enabled| & valid strings are 'true' and 'false' - 'true' for use of DETA.\\
\verb|deltaPhi.enabled| & valid strings are 'true' and 'false' - 'true' for use of DPHI.\\
\verb|deltaR.enabled| & valid strings are 'true' and 'false' - 'true' for use of DR.\\
\verb|mass.enabled| & valid strings are 'true' and 'false' - 'true' for use of MASS.\\
\verb|mass.type| & valid strings are 'INVARIANT\_MASS\_TYPE' and 'TRANSVERSE\_MASS\_TYPE'.\\
\verb|twoBodyPt.enabled| & valid strings are 'true' and 'false' - 'true' for use of two-body pt.\\
\verb|sliceLow| & low value of an object slice.\\
\verb|sliceHigh| & high value of an object slice.\\
\verb|operator| & valid strings are 'true' and 'false' - 'true' for greater/equal-, 'false' for equal-mode of \et comparator.\\
\verb|threshold| & requirements for et\_thresholds (16-bit values, hex notation). Valid values depending on the scales of \et.\\
\verb|nrEtaWindows| & number of $\eta$ cuts.\\
\verb|etaW1UpperLimit, ...| & limits for "window"-comparators for $\eta$ (4x 16-bit values, hex notation). Valid values depending on the scales for $\eta$.\\
\verb|phiFullRange| & set full range of $\varphi$ (boolean).\\
\verb|phiW1UpperLimit, ...| & limits for "window"-comparators for $\varphi$ (16-bit values, hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|[phiW2Ignore| & ignore "window"-comparator 2 of $\varphi$ (boolean).\\
\verb|isolationLUT| & LUT (4 bits) of isolation).\\
\verb|deltaEta.upper, ...| & limits for "window"-comparator for comparison of differences in $\eta$ (hex notation). Valid values depending on the scales for $\eta$.\\
\verb|deltaPhi.upper, ...| & limits for "window"-comparator for comparison of differences in $\varphi$ (hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|deltaR.upper, ...| & limits for "window"-comparator for comparison of $\Delta$$R^2$ (hex notation).\\
\verb|mass.upper, ...| & limits for "window"-comparator for comparison of $\frac{M^2}{2}$ (hex notation).\\
\verb|twoBodyPt.threshold| & value of threshold for two-body pt comparison.\\
\verb|bx| & valid strings are 'p2', 'p1', '0', 'm1' and 'm2'. This indicates which data in a range of plus/minus 2 bunch-crossing is used in the condition.\\
\hline 
\label{tab:gtl:explanation_instance_calo_calo_correlation_condition_vhd}
\end{longtable}

\clearpage

\subsubsection{Calo Muon Correlation condition - template for VHDL-Producer}
A VHDL-template for VHDL-Producer of instantiating\\ \texttt{calo\_muon\_correlation\_condition.vhd}\\ is given below (see Listing~\ref{lst:instance_calo_muon_correlation_condition_vhd}).\\

%% "automatic generation" of listings (see /scripts/extract_entities.sh)
\lstinputlisting[label=lst:instance_calo_muon_correlation_condition_vhd,language=VHDL,caption=Template of \texttt{calo\_muon\_correlation\_condition.vhd} for VHDL-Producer]{interfaces/instance_calo_muon_correlation_condition.vhd.j2}

\begin{longtable}{>{\footnotesize}l >{\footnotesize}p{.65\columnwidth}}
\caption{Explanation of Listing~\ref{lst:instance_calo_muon_correlation_condition_vhd}}\\
\hline 
{Item} & {Explanation}\\
\hline 
\endhead
\verb|vhdl_signal| & condition name.\\
\verb|deltaEta.enabled| & valid strings are 'true' and 'false' - 'true' for use of DETA.\\
\verb|deltaPhi.enabled| & valid strings are 'true' and 'false' - 'true' for use of DPHI.\\
\verb|deltaR.enabled| & valid strings are 'true' and 'false' - 'true' for use of DR.\\
\verb|mass.enabled| & valid strings are 'true' and 'false' - 'true' for use of MASS.\\
\verb|mass.type| & valid strings are 'INVARIANT\_MASS\_TYPE' and 'TRANSVERSE\_MASS\_TYPE'.\\
\verb|twoBodyPt.enabled| & valid strings are 'true' and 'false' - 'true' for use of two-body pt.\\
\verb|sliceLow| & low value of an object slice.\\
\verb|sliceHigh| & high value of an object slice.\\
\verb|operator| & valid strings are 'true' and 'false' - 'true' for greater/equal-, 'false' for equal-mode of \et comparator.\\
\verb|threshold| & requirements for et\_thresholds and pt\_thresholds (16-bit values, hex notation). Valid values depending on the scales of \et.\\
\verb|nrEtaWindows| & number of $\eta$ cuts.\\
\verb|etaW1UpperLimit, ...| & limits for "window"-comparators for $\eta$ (4x 16-bit values, hex notation). Valid values depending on the scales for $\eta$.\\
\verb|phiFullRange| & set full range of $\varphi$ (boolean).\\
\verb|phiW1UpperLimit, ...| & limits for "window"-comparators for $\varphi$ (16-bit values, hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|[phiW2Ignore| & ignore "window"-comparator 2 of $\varphi$ (boolean).\\
\verb|charge| & requested charge. Valid strings are 'pos' ("positive charge") and 'neg' ("negative charge") and 'ign' ("ignore").\\
\verb|qualityLUT| & LUT (16 bits) of quality.\\
\verb|isolationLUT| & LUT (4 bits) of isolation).\\
\verb|uptCutSel| & set use of unconstrained \pt.\\
\verb|uptUpperLimit, ...| & limits for unconstrained \pt.\\
\verb|impactParameterLUT| & LUT (4 bits) of impact parameter).\\
\verb|deltaEta.upper, ...| & limits for "window"-comparator for comparison of differences in $\eta$ (hex notation). Valid values depending on the scales for $\eta$.\\
\verb|deltaPhi.upper, ...| & limits for "window"-comparator for comparison of differences in $\varphi$ (hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|deltaR.upper, ...| & limits for "window"-comparator for comparison of $\Delta$$R^2$ (hex notation).\\
\verb|mass.upper, ...| & limits for "window"-comparator for comparison of $\frac{M^2}{2}$ (hex notation).\\
\verb|twoBodyPt.threshold| & value of threshold for two-body pt comparison.\\
\verb|bx| & valid strings are 'p2', 'p1', '0', 'm1' and 'm2'. This indicates which data in a range of plus/minus 2 bunch-crossing is used in the condition.\\
\hline 
\label{tab:gtl:explanation_instance_calo_muon_correlation_condition_vhd}
\end{longtable}

\clearpage

\subsubsection{Muon Muon Correlation condition - template for VHDL-Producer}
A VHDL-template for VHDL-Producer of instantiating\\ \texttt{muon\_muon\_correlation\_condition.vhd}\\ is given below (see Listing~\ref{lst:instance_muon_muon_correlation_condition_vhd}).\\

%% "automatic generation" of listings (see /scripts/extract_entities.sh)
\lstinputlisting[label=lst:instance_muon_muon_correlation_condition_vhd,language=VHDL,caption=Template of \texttt{muon\_muon\_correlation\_condition.vhd} for VHDL-Producer]{interfaces/instance_muon_muon_correlation_condition.vhd.j2}

\begin{longtable}{>{\footnotesize}l >{\footnotesize}p{.65\columnwidth}}
\caption{Explanation of Listing~\ref{lst:instance_muon_muon_correlation_condition_vhd}}\\
\hline 
{Item} & {Explanation}\\
\hline 
\endhead
\verb|vhdl_signal| & condition name.\\
\verb|objectsInSameBx| & valid strings are 'true' and 'false' - 'true' for data with same Bx.\\
\verb|deltaEta.enabled| & valid strings are 'true' and 'false' - 'true' for use of DETA.\\
\verb|deltaPhi.enabled| & valid strings are 'true' and 'false' - 'true' for use of DPHI.\\
\verb|deltaR.enabled| & valid strings are 'true' and 'false' - 'true' for use of DR.\\
\verb|mass.enabled| & valid strings are 'true' and 'false' - 'true' for use of MASS.\\
\verb|mass.type| & valid strings are 'INVARIANT\_MASS\_TYPE' and 'TRANSVERSE\_MASS\_TYPE'.\\
\verb|twoBodyPt.enabled| & valid strings are 'true' and 'false' - 'true' for use of two-body pt.\\
\verb|sliceLow| & low value of an object slice.\\
\verb|sliceHigh| & high value of an object slice.\\
\verb|operator| & valid strings are 'true' and 'false' - 'true' for greater/equal-, 'false' for equal-mode of \et comparator.\\
\verb|threshold| & requirements for pt\_thresholds (16-bit values, hex notation). Valid values depending on the scales of \et.\\
\verb|nrEtaWindows| & number of $\eta$ cuts.\\
\verb|etaW1UpperLimit, ...| & limits for "window"-comparators for $\eta$ (4x 16-bit values, hex notation). Valid values depending on the scales for $\eta$.\\
\verb|phiFullRange| & set full range of $\varphi$ (boolean).\\
\verb|phiW1UpperLimit, ...| & limits for "window"-comparators for $\varphi$ (16-bit values, hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|[phiW2Ignore| & ignore "window"-comparator 2 of $\varphi$ (boolean).\\
\verb|charge| & requested charge. Valid strings are 'pos' ("positive charge") and 'neg' ("negative charge") and 'ign' ("ignore").\\
\verb|qualityLUT| & LUT (16 bits) of quality.\\
\verb|isolationLUT| & LUT (4 bits) of isolation).\\
\verb|uptCutSel| & set use of unconstrained \pt.\\
\verb|uptUpperLimit, ...| & limits for unconstrained \pt.\\
\verb|impactParameterLUT| & LUT (4 bits) of impact parameter).\\
\verb|deltaEta.upper, ...| & limits for "window"-comparator for comparison of differences in $\eta$ (hex notation). Valid values depending on the scales for $\eta$.\\
\verb|deltaPhi.upper, ...| & limits for "window"-comparator for comparison of differences in $\varphi$ (hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|deltaR.upper, ...| & limits for "window"-comparator for comparison of $\Delta$$R^2$ (hex notation).\\
\verb|mass.upper, ...| & limits for "window"-comparator for comparison of $\frac{M^2}{2}$ (hex notation).\\
\verb|twoBodyPt.threshold| & value of threshold for two-body pt comparison.\\
\verb|bx| & valid strings are 'p2', 'p1', '0', 'm1' and 'm2'. This indicates which data in a range of plus/minus 2 bunch-crossing is used in the condition.\\
\hline 
\label{tab:gtl:explanation_instance_muon_muon_correlation_condition_vhd}
\end{longtable}

\subsubsection{Calo Esums Correlation condition - template for VHDL-Producer}
A VHDL-template for VHDL-Producer of instantiating\\ \texttt{calo\_esums\_correlation\_condition.vhd}\\ is given below (see Listing~\ref{lst:instance_calo_calo_correlation_condition_vhd}).\\

% %% "automatic generation" of listings (see /scripts/extract_entities.sh)
% \lstinputlisting[label=lst:instance_calo_esums_correlation_condition_vhd,language=VHDL,caption=Template of \texttt{calo\_esums\_correlation\_condition.vhd} for VHDL-Producer]{interfaces/instance_calo_esums_correlation_condition.vhd.j2}

\begin{longtable}{>{\footnotesize}l >{\footnotesize}p{.65\columnwidth}}
\caption{Explanation of Listing~\ref{lst:instance_calo_calo_correlation_condition_vhd}}\\
\hline 
{Item} & {Explanation}\\
\hline 
\endhead
\verb|vhdl_signal| & condition name.\\
\verb|deltaPhi.enabled| & valid strings are 'true' and 'false' - 'true' for use of DPHI.\\
\verb|mass.enabled| & valid strings are 'true' and 'false' - 'true' for use of MASS.\\
\verb|mass.type| & valid string: 'TRANSVERSE\_MASS\_TYPE'.\\
\verb|twoBodyPt.enabled| & valid strings are 'true' and 'false' - 'true' for use of two-body pt.\\
\verb|sliceLow| & low value of an object slice.\\
\verb|sliceHigh| & high value of an object slice.\\
\verb|operator| & valid strings are 'true' and 'false' - 'true' for greater/equal-, 'false' for equal-mode of \et comparator.\\
\verb|threshold| & requirements for et\_thresholds (16-bit values, hex notation). Valid values depending on the scales of \et.\\
\verb|nrEtaWindows| & number of $\eta$ cuts.\\
\verb|etaW1UpperLimit, ...| & limits for "window"-comparators for $\eta$ (4x 16-bit values, hex notation). Valid values depending on the scales for $\eta$.\\
\verb|phiFullRange| & set full range of $\varphi$ (boolean).\\
\verb|phiW1UpperLimit, ...| & limits for "window"-comparators for $\varphi$ (16-bit values, hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|[phiW2Ignore| & ignore "window"-comparator 2 of $\varphi$ (boolean).\\
\verb|isolationLUT| & LUT (4 bits) of isolation).\\
\verb|deltaPhi.upper, ...| & limits for "window"-comparator for comparison of differences in $\varphi$ (hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|mass.upper, ...| & limits for "window"-comparator for comparison of $\frac{M^2}{2}$ (hex notation).\\
\verb|twoBodyPt.threshold| & value of threshold for two-body pt comparison.\\
\verb|bx| & valid strings are 'p2', 'p1', '0', 'm1' and 'm2'. This indicates which data in a range of plus/minus 2 bunch-crossing is used in the condition.\\
\hline 
\label{tab:gtl:explanation_instance_calo_calo_correlation_condition_vhd}
\end{longtable}


\subsubsection{Muon Esums Correlation condition - template for VHDL-Producer}
A VHDL-template for VHDL-Producer of instantiating\\ \texttt{muon\_esums\_correlation\_condition.vhd}\\ is given below (see Listing~\ref{lst:instance_muon_esums_correlation_condition_vhd}).\\

% %% "automatic generation" of listings (see /scripts/extract_entities.sh)
% \lstinputlisting[label=lst:instance_muon_esums_correlation_condition_vhd,language=VHDL,caption=Template of \texttt{muon\_esums\_correlation\_condition.vhd} for VHDL-Producer]{interfaces/instance_muon_esums_correlation_condition.vhd.j2}

\begin{longtable}{>{\footnotesize}l >{\footnotesize}p{.65\columnwidth}}
\caption{Explanation of Listing~\ref{lst:instance_calo_muon_correlation_condition_vhd}}\\
\hline 
{Item} & {Explanation}\\
\hline 
\endhead
\verb|vhdl_signal| & condition name.\\
\verb|deltaPhi.enabled| & valid strings are 'true' and 'false' - 'true' for use of DPHI.\\
\verb|mass.enabled| & valid strings are 'true' and 'false' - 'true' for use of MASS.\\
\verb|mass.type| & valid string: 'TRANSVERSE\_MASS\_TYPE'.\\
\verb|twoBodyPt.enabled| & valid strings are 'true' and 'false' - 'true' for use of two-body pt.\\
\verb|sliceLow| & low value of an object slice.\\
\verb|sliceHigh| & high value of an object slice.\\
\verb|operator| & valid strings are 'true' and 'false' - 'true' for greater/equal-, 'false' for equal-mode of \et comparator.\\
\verb|threshold| & requirements for pt\_thresholds and et\_thresholds (16-bit values, hex notation). Valid values depending on the scales of \et.\\
\verb|nrEtaWindows| & number of $\eta$ cuts.\\
\verb|etaW1UpperLimit, ...| & limits for "window"-comparators for $\eta$ (4x 16-bit values, hex notation). Valid values depending on the scales for $\eta$.\\
\verb|phiFullRange| & set full range of $\varphi$ (boolean).\\
\verb|phiW1UpperLimit, ...| & limits for "window"-comparators for $\varphi$ (16-bit values, hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|[phiW2Ignore| & ignore "window"-comparator 2 of $\varphi$ (boolean).\\
\verb|charge| & requested charge. Valid strings are 'pos' ("positive charge") and 'neg' ("negative charge") and 'ign' ("ignore").\\
\verb|qualityLUT| & LUT (16 bits) of quality.\\
\verb|isolationLUT| & LUT (4 bits) of isolation).\\
\verb|uptCutSel| & set use of unconstrained \pt.\\
\verb|uptUpperLimit, ...| & limits for unconstrained \pt.\\
\verb|impactParameterLUT| & LUT (4 bits) of impact parameter).\\
\verb|deltaPhi.upper, ...| & limits for "window"-comparator for comparison of differences in $\varphi$ (hex notation). Valid values depending on the scales for $\varphi$.\\
\verb|mass.upper, ...| & limits for "window"-comparator for comparison of $\frac{M^2}{2}$ (hex notation).\\
\verb|twoBodyPt.threshold| & value of threshold for two-body pt comparison.\\
\verb|bx| & valid strings are 'p2', 'p1', '0', 'm1' and 'm2'. This indicates which data in a range of plus/minus 2 bunch-crossing is used in the condition.\\
\hline 
\label{tab:gtl:explanation_instance_calo_muon_correlation_condition_vhd}
\end{longtable}


\clearpage


